// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"


/*@
axiomatic real_function_quadrant {
logic integer quadrant (real X, real Y) =
(0 <= X && 0 <= Y)
? 1 :
(X <= 0 && 0 <= Y)
? 2 :
(X <= 0)
? 3 :
4;
}
*/


/*@
axiomatic fp_function_fp_quadrant {
logic integer fp_quadrant (double double_X, double double_Y) =
(((round(0) <= double_X) && (round(0) <= double_Y)))
? 1 :
(((double_X <= round(0)) && (round(0) <= double_Y)))
? 2 :
((double_X <= round(0)))
? 3 :
4;
}
*/


/*@ axiomatic quadrant_trans {
predicate quadrant_stable_paths (real X, real Y, double double_X, double double_Y) =
X <= 0 && 0 <= Y && ! (0 <= X && 0 <= Y) && (((double_X <= round(0)) && (round(0) <= double_Y)) && ! (((round(0) <= double_X) && (round(0) <= double_Y)))) || ! (X <= 0) && ! (X <= 0 && 0 <= Y) && ! (0 <= X && 0 <= Y) && (! ((double_X <= round(0))) && (! (((double_X <= round(0)) && (round(0) <= double_Y))) && ! (((round(0) <= double_X) && (round(0) <= double_Y))))) || 0 <= X && 0 <= Y && ((round(0) <= double_X) && (round(0) <= double_Y)) || X <= 0 && ! (X <= 0 && 0 <= Y) && ! (0 <= X && 0 <= Y) && ((double_X <= round(0)) && (! (((double_X <= round(0)) && (round(0) <= double_Y))) && ! (((round(0) <= double_X) && (round(0) <= double_Y)))));
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 ;
assigns \nothing;

behavior structure:
ensures \result.isValid
        ==> ((\result.value == fp_quadrant(double_X, double_Y))) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real X, real Y; (\abs(double_X - X) <= double_E_0 && \abs(double_Y - Y) <= double_E_1
                                      ==> (quadrant_stable_paths(X, Y, double_X, double_Y)))) ;
*/
struct maybeInt quadrant_int (double double_X, double double_Y, double double_E_0, double double_E_1) {
  struct maybeInt res;
  if ((double_E_0 <= double_X) && (double_E_1 <= double_Y))
  { res = some(1);;
  }
  else if (((double_X <= - (double_E_0)) && (double_E_1 <= double_Y)) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
  { res = some(2);; }
  else if (((double_X <= - (double_E_0)) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
  { res = some(3);; }
  else if (((double_E_0 < double_X) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
  { res = some(4);; }
  else { res = none();
  }
  return res;
}


/*@
ensures \forall real X, real Y; (-60000 <= X && X <= 60000 && -10000 <= Y && Y <= 10000 && \result.isValid && \abs(double_X - X) <= \ulp_dp(X)/2 && \abs(double_Y - Y) <= \ulp_dp(Y)/2)
        ==> (\abs((\result.value - quadrant(X, Y))) <= 0x0p+0) ;
*/
struct maybeInt quadrant_num (double double_X, double double_Y) {
  return quadrant_int (double_X, double_Y, 0x1p-38, 0x1p-40);
}
/*@
axiomatic real_function_winding_number_contrib {
logic integer winding_number_contrib (real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y) =
\let THIS_x = (P_V1_x - S_x) ;
\let THIS_y = (P_V1_y - S_y) ;
\let NEXT_x = (P_V2_x - S_x) ;
\let NEXT_y = (P_V2_y - S_y) ;
\let DISTANCE_x = (NEXT_x - THIS_x) ;
\let DISTANCE_y = (NEXT_y - THIS_y) ;
\let DET = ((DISTANCE_x * THIS_y) - (DISTANCE_y * THIS_x)) ;
\let K = quadrant(THIS_x, THIS_y) ;
\let P = quadrant(NEXT_x, NEXT_y) ;
((K == P)
 ? 0 :
 ((P - 1) == (K % 4))
 ? 1 :
 ((K - 1) == (P % 4))
 ? -1 :
 (DET <= 0)
 ? 2 :
 -2);
}
*/


/*@
axiomatic fp_function_fp_winding_number_contrib {
logic integer fp_winding_number_contrib (double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y) =
\let THIS_x = Dsub(double_P_V1_x, double_S_x) ;
\let THIS_y = Dsub(double_P_V1_y, double_S_y) ;
\let NEXT_x = Dsub(double_P_V2_x, double_S_x) ;
\let NEXT_y = Dsub(double_P_V2_y, double_S_y) ;
\let DISTANCE_x = Dsub(double_NEXT_x, double_THIS_x) ;
\let DISTANCE_y = Dsub(double_NEXT_y, double_THIS_y) ;
\let DET = Dsub(Dmul(double_DISTANCE_x, double_THIS_y), Dmul(double_DISTANCE_y, double_THIS_x)) ;
\let K = quadrant(double_THIS_x, double_THIS_y) ;
\let P = quadrant(double_NEXT_x, double_NEXT_y) ;
(((K == P))
 ? 0 :
 ((Isub(P, 1) == Imod(K, 4)))
 ? 1 :
 ((Isub(K, 1) == Imod(P, 4)))
 ? -1 :
 ((double_DET <= round(0)))
 ? 2 :
 -2);
}
*/


/*@ axiomatic winding_number_contrib_trans {
predicate winding_number_contrib_stable_paths (real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y, double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y) =
! (((((P_V2_x - S_x) - (P_V1_x - S_x)) * (P_V1_y - S_y)) - (((P_V2_y - S_y) - (P_V1_y - S_y)) * (P_V1_x - S_x))) <= 0) && ! ((quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4)) && ! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4)) && ! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y))) && (! ((Dsub(Dmul(Dsub(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V1_x, double_S_x)), Dsub(double_P_V1_y, double_S_y)), Dmul(Dsub(Dsub(double_P_V2_y, double_S_y), Dsub(double_P_V1_y, double_S_y)), Dsub(double_P_V1_x, double_S_x))) <= round(0))) && (! ((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4))) && (! ((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4))) && ! ((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) == quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y))))))) || (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4) && ! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4)) && ! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y))) && ((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4)) && (! ((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4))) && ! ((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) == quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)))))) || (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4) && ! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y))) && ((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4)) && ! ((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) == quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y))))) || ((((P_V2_x - S_x) - (P_V1_x - S_x)) * (P_V1_y - S_y)) - (((P_V2_y - S_y) - (P_V1_y - S_y)) * (P_V1_x - S_x))) <= 0 && ! ((quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4)) && ! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4)) && ! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y))) && ((Dsub(Dmul(Dsub(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V1_x, double_S_x)), Dsub(double_P_V1_y, double_S_y)), Dmul(Dsub(Dsub(double_P_V2_y, double_S_y), Dsub(double_P_V1_y, double_S_y)), Dsub(double_P_V1_x, double_S_x))) <= round(0)) && (! ((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4))) && (! ((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1) == Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4))) && ! ((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) == quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y))))))) || quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y)) && (quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) == quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)));
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4 ;
assigns \nothing;

behavior structure:
ensures \result.isValid
        ==> ((\result.value == fp_winding_number_contrib(double_P_V1_x, double_P_V1_y, double_P_V2_x, double_P_V2_y, double_S_x, double_S_y))) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y; (\abs(double_THIS_x - THIS_x) <= double_E_0 && \abs(double_THIS_y - THIS_y) <= double_E_1 && \abs(double_NEXT_x - NEXT_x) <= double_E_2 && \abs(double_NEXT_y - NEXT_y) <= double_E_3 && \abs(double_DET - DET) <= double_E_4
                                                                                              ==> (\let THIS_x = (P_V1_x - S_x);
                                                                                                   \let THIS_x = Dsub(double_P_V1_x, double_S_x);
                                                                                                   winding_number_contrib_stable_paths(P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y, double_P_V1_x, double_P_V1_y, double_P_V2_x, double_P_V2_y, double_S_x, double_S_y)))) ;
*/
struct maybeInt winding_number_contrib_int (double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4) {
  struct maybeInt res;
  double double_THIS_x = (double_P_V1_x - double_S_x);
  double double_THIS_y = (double_P_V1_y - double_S_y);
  double double_NEXT_x = (double_P_V2_x - double_S_x);
  double double_NEXT_y = (double_P_V2_y - double_S_y);
  double double_DISTANCE_x = (double_NEXT_x - double_THIS_x);
  double double_DISTANCE_y = (double_NEXT_y - double_THIS_y);
  double double_DET = ((double_DISTANCE_x * double_THIS_y) - (double_DISTANCE_y * double_THIS_x));
  struct maybeInt aux_0 = quadrant_int (double_THIS_x, double_THIS_y, double_E_0, double_E_1);
  if (aux_0.isValid)
  { int K = aux_0.value;
    struct maybeInt aux_1 = quadrant_int (double_NEXT_x, double_NEXT_y, double_E_2, double_E_3);
    if (aux_1.isValid)
    { int P = aux_1.value;
      if (K == P)
      { res = some(0);;
      }
      else if ((P - 1) == (K % 4))
      { res = some(1);; }
      else if ((K - 1) == (P % 4))
      { res = some(-1);; }
      else if (double_DET <= - (double_E_4))
      { res = some(2);; }
      else if (double_E_4 < double_DET)
      { res = some(-2);; }
      else { res = none();
      }
    } else { res = none();
    }
  } else { res = none();
  }
  return res;
}


/*@
ensures \forall real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y; (-60000 <= P_V1_x && P_V1_x <= 60000 && -60000 <= P_V1_y && P_V1_y <= 60000 && -60000 <= P_V2_x && P_V2_x <= 60000 && -60000 <= P_V2_y && P_V2_y <= 60000 && -60000 <= S_x && S_x <= 60000 && -60000 <= S_y && S_y <= 60000 && \result.isValid && \abs(double_P_V1_x - P_V1_x) <= \ulp_dp(P_V1_x)/2 && \abs(double_P_V1_y - P_V1_y) <= \ulp_dp(P_V1_y)/2 && \abs(double_P_V2_x - P_V2_x) <= \ulp_dp(P_V2_x)/2 && \abs(double_P_V2_y - P_V2_y) <= \ulp_dp(P_V2_y)/2 && \abs(double_S_x - S_x) <= \ulp_dp(S_x)/2 && \abs(double_S_y - S_y) <= \ulp_dp(S_y)/2)
        ==> (\abs((\result.value - winding_number_contrib(P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y))) <= 0x0p+0) ;
*/
struct maybeInt winding_number_contrib_num (double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y) {
  return winding_number_contrib_int (double_P_V1_x, double_P_V1_y, double_P_V2_x, double_P_V2_y, double_S_x, double_S_y, 0x1p-36, 0x1p-36, 0x1p-36, 0x1p-36, 0x1.0d14000000001p-16);
}
/*@
axiomatic real_function_for_winding_number1 {
logic integer for_winding_number1{L} (integer I, integer Acc, integer N, real *Px, real *Py, real Sx, real Sy) =
I == 2 ? (Acc) : (for_winding_number1((I + 1), I < 2 ? ((Acc + winding_number_contrib(Px[I], Py[I], Px[(I + 1)], Py[(I + 1)], Sx, Sy))) : ((Acc + winding_number_contrib(Px[I], Py[I], Px[0], Py[0], Sx, Sy))), N, Px, Py, Sx, Sy));
}
*/
/*@
axiomatic real_function_winding_number {
logic integer winding_number (integer N, real *Px, real *Py, real Sx, real Sy) =
for_winding_number1(0, 0, N, Px, Py, Sx, Sy);
}
*/
/*@
axiomatic fp_function_fp_for_winding_number1 {
logic integer fp_for_winding_number1{L} (integer I, integer Acc, integer N, double *Px, double *Py, double double_Sx, double double_Sy) =
(I == 2) ? (Acc) : (for_winding_number1(Iadd(I, 1), (I < 2) ? (Iadd(Acc, winding_number_contrib(Px[I], Py[I], Px[Iadd(I, 1)], Py[Iadd(I, 1)], double_Sx, double_Sy))) : (Iadd(Acc, winding_number_contrib(Px[I], Py[I], Px[0], Py[0], double_Sx, double_Sy))), N, Px, Py, double_Sx, double_Sy));
}
*/


/*@
axiomatic fp_function_fp_winding_number {
logic integer fp_winding_number (integer N, double *Px, double *Py, double double_Sx, double double_Sy) =
for_winding_number1(0, 0, N, Px, Py, double_Sx, double_Sy);
}
*/


/*@ axiomatic winding_number_trans {
predicate winding_number_stable_paths (real Sx, real Sy, integer N, double double_Px, double double_Py, double double_Sx, double double_Sy) =
\forall integer I; ((0 <= I <= 2)
                    ==> (\true && \true));
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 ;
assigns \nothing;

behavior structure:
ensures \result.isValid
        ==> ((\result.value == fp_winding_number(N, Px, Py, double_Sx, double_Sy))) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real Sx, real Sy; ((I < 2)
                                        ==> (\abs(Dsub(Px[I], double_Sx) - (Px[I] - Sx)) <= double_E_0) && (I < 2)
                                                                                                           ==> (\abs(Dsub(Py[I], double_Sy) - (Py[I] - Sy)) <= double_E_1) && (I < 2)
                                                                                                                                                                              ==> (\abs(Dsub(Px[Iadd(I, 1)], double_Sx) - (Px[(I + 1)] - Sx)) <= double_E_0) && (I < 2)
                                                                                                                                                                                                                                                                ==> (\abs(Dsub(Py[Iadd(I, 1)], double_Sy) - (Py[(I + 1)] - Sy)) <= double_E_1) && (I < 2)
                                                                                                                                                                                                                                                                                                                                                  ==> (\abs(Dsub(Dmul(Dsub(Dsub(Px[Iadd(I, 1)], double_Sx), Dsub(Px[I], double_Sx)), Dsub(Py[I], double_Sy)), Dmul(Dsub(Dsub(Py[Iadd(I, 1)], double_Sy), Dsub(Py[I], double_Sy)), Dsub(Px[I], double_Sx))) - ((((Px[(I + 1)] - Sx) - (Px[I] - Sx)) * (Py[I] - Sy)) - (((Py[(I + 1)] - Sy) - (Py[I] - Sy)) * (Px[I] - Sx)))) <= double_E_2) && ! ((I < 2))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ==> (\abs(Dsub(Px[0], double_Sx) - (Px[0] - Sx)) <= double_E_0) && ! ((I < 2))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ==> (\abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1) && ! ((I < 2))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ==> (\abs(Dsub(Dmul(Dsub(Dsub(Px[0], double_Sx), Dsub(Px[I], double_Sx)), Dsub(Py[I], double_Sy)), Dmul(Dsub(Dsub(Py[0], double_Sy), Dsub(Py[I], double_Sy)), Dsub(Px[I], double_Sx))) - ((((Px[0] - Sx) - (Px[I] - Sx)) * (Py[I] - Sy)) - (((Py[0] - Sy) - (Py[I] - Sy)) * (Px[I] - Sx)))) <= double_E_2)
                                        ==> (winding_number_stable_paths(Sx, Sy, N, double_Px, double_Py, double_Sx, double_Sy)))) ;
*/
struct maybeInt winding_number_int (int N, double *Px, double *Py, double double_Sx, double double_Sy, double double_E_0, double double_E_1, double double_E_2) {
  struct maybeInt res;
  int I;
  int Acc = 0;
  res = some(Acc);
  /*@
  loop assigns I, Acc, res ;
  loop invariant (I <= 0 <= 2) && I > 0
                 ==> (\abs((Acc - for_winding_number1((I - 1), Acc, N, Px, Py, Sx, Sy))) <= 0) ;
  loop variant (2 - I) ;
  @*/
  for(I=0; I<=2; I++) {
  if (res.isValid)
  { struct maybeInt aux_0 = winding_number_contrib_int (Px[I], Py[I], Px[(I + 1)], Py[(I + 1)], double_Sx, double_Sy, double_E_0, double_E_1, double_E_0, double_E_1, double_E_2);
    struct maybeInt aux_1 = winding_number_contrib_int (Px[I], Py[I], Px[0], Py[0], double_Sx, double_Sy, double_E_0, double_E_1, double_E_0, double_E_1, double_E_2);
    if ((aux_0.isValid) && (aux_1.isValid))
    { if (I < 2)
      { struct maybeInt aux_2 = aux_0;
        if (aux_0.isValid)
        { res = some((Acc + aux_0.value));
        } else { res = none();
        }
      } else { struct maybeInt aux_3 = aux_1;
               if (aux_1.isValid)
               { res = some((Acc + aux_1.value));
               } else { res = none();
               }
      }
    } else { res = none();
    }
  } else { res = none();
  };
  }
  return res;
}


/*@
ensures \forall integer N, real * Px, real * Py, real Sx, real Sy; (\forall integer I; ((0 <= I <= 2))
                                                                    ==> (1 <= N && N <= 6 && -60000 <= Px && Px <= 60000 && -60000 <= Py && Py <= 60000 && -60000 <= Sx && Sx <= 60000 && -60000 <= Sy && Sy <= 60000) && \result.isValid && \abs(double_Px - Px) <= \ulp_dp(Px)/2 && \abs(double_Py - Py) <= \ulp_dp(Py)/2 && \abs(double_Sx - Sx) <= \ulp_dp(Sx)/2 && \abs(double_Sy - Sy) <= \ulp_dp(Sy)/2)
        ==> (\abs((\result.value - winding_number(N, Px, Py, Sx, Sy))) <= 0x0p+0) ;
*/
struct maybeInt winding_number_num (int N, double *Px, double *Py, double double_Sx, double double_Sy) {
  return winding_number_int (N, Px, Py, double_Sx, double_Sy, 0x1p-36, 0x1p-36, 0x1.d4c0000000006p-18);
}


int main () { return 0; }