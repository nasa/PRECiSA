// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"


/*@
axiomatic real_function_sign {
logic integer sign (real x) =
x >= 0 ? (1) : (-1);
}
*/


/*@
axiomatic fp_function_fp_sign {
logic integer fp_sign (double double_x) =
(double_x >= round(0)) ? (1) : (-1);
}
*/


/*@ axiomatic sign_trans {
predicate sign_stable_paths (real x, double double_x) =
! (x >= 0) && ! ((double_x >= round(0))) || x >= 0 && (double_x >= round(0));
}
*/


/*@
requires 0 <= double_E_0 ;
assigns \nothing;

behavior structure:
ensures \result.isValid
        ==> ((\result.value == fp_sign(double_x))) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real x; (\abs(double_x - x) <= double_E_0
                              ==> (sign_stable_paths(x, double_x)))) ;
*/
struct maybeInt sign_int (double double_x, double double_E_0) {
  struct maybeInt res;
  if (double_x >= double_E_0)
  { res = some(1);
  } else { if (double_x < - (double_E_0))
           { res = some(-1);
           } else { res = none();
           }
  }
  return res;
}


/*@
ensures \forall real x; (-10000 <= x && x <= 10000 && \result.isValid && \abs(double_x - x) <= \ulp_dp(x)/2)
        ==> (\abs((\result.value - sign(x))) <= 0x0p+0) ;
*/
struct maybeInt sign_num (double double_x) {
  return sign_int (double_x, 0x1p-40);
}
/*@
axiomatic real_function_quadratic {
logic real quadratic (real a, real b, real c, real x) =
((((a * x) * x) + (b * x)) + c);
}
*/


/*@
axiomatic fp_function_fp_quadratic {
logic double fp_quadratic (double double_a, double double_b, double double_c, double double_x) =
Dadd(Dadd(Dmul(Dmul(double_a, double_x), double_x), Dmul(double_b, double_x)), double_c);
}
*/


/*@ axiomatic quadratic_trans {
predicate quadratic_stable_paths (real a, real b, real c, real x, double double_a, double double_b, double double_c, double double_x) =
\true && \true;
}
*/


/*@
assigns \nothing;

behavior structure:
ensures \result.isValid
        ==> ((\result.value == fp_quadratic(double_a, double_b, double_c, double_x))) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real a, real b, real c, real x; (quadratic_stable_paths(a, b, c, x, double_a, double_b, double_c, double_x))) ;
*/
struct maybeDouble quadratic_double (double double_a, double double_b, double double_c, double double_x) {
  struct maybeDouble res;
  res = someDouble(((((double_a * double_x) * double_x) + (double_b * double_x)) + double_c));
  return res;
}


/*@
ensures \forall real a, real b, real c, real x; (-10000 <= a && a <= 10000 && -10000 <= b && b <= 10000 && -10000 <= c && c <= 10000 && -10000 <= x && x <= 10000 && \result.isValid && \abs(double_a - a) <= \ulp_dp(a)/2 && \abs(double_b - b) <= \ulp_dp(b)/2 && \abs(double_c - c) <= \ulp_dp(c)/2 && \abs(double_x - x) <= \ulp_dp(x)/2)
        ==> (\abs((\result.value - quadratic(a, b, c, x))) <= 0x1.1620890800002p-11) ;
*/
struct maybeDouble quadratic_num (double double_a, double double_b, double double_c, double double_x) {
  return quadratic_double (double_a, double_b, double_c, double_x);
}
/*@
axiomatic real_pred_quad_min_le_D_int {
logic boolean quad_min_le_D_int (real ap, real b, real c, real xl, real xu, real D) =
(xl - xu) <= 0 || (((2 * ap) * xl) + b) <= 0 && 0 <= (((2 * ap) * xu) + b) && ((b * b) - ((4 * ap) * (c - D))) > 0 || quadratic(ap, b, (c - D), xl) < 0 || quadratic(ap, b, (c - D), xu) < 0;
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4 && 0 <= double_E_5 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (quad_min_le_D_int(double_ap, double_b, double_c, double_xl, double_xu, double_D)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real ap, real b, real c, real xl, real xu, real D; (\abs(Dsub(double_xl, double_xu) - (xl - xu)) <= double_E_0 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), double_xl), double_b) - (((2 * ap) * xl) + b)) <= double_E_1 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), double_xu), double_b) - (((2 * ap) * xu) + b)) <= double_E_2 && \abs(Dsub(Dmul(double_b, double_b), Dmul(Dmul(round(4), double_ap), Dsub(double_c, double_D))) - ((b * b) - ((4 * ap) * (c - D)))) <= double_E_3 && \abs(quadratic(double_ap, double_b, Dsub(double_c, double_D), double_xl) - quadratic(ap, b, (c - D), xl)) <= double_E_4 && \abs(quadratic(double_ap, double_b, Dsub(double_c, double_D), double_xu) - quadratic(ap, b, (c - D), xu)) <= double_E_5
                                                                         ==> (quad_min_le_D_int_stable_paths(ap, b, c, xl, xu, D, double_ap, double_b, double_c, double_xl, double_xu, double_D)))) ;
*/
struct maybeBool quad_min_le_D_int_tauplus_bool (double double_ap, double double_b, double double_c, double double_xl, double double_xu, double double_D, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4, double double_E_5) {
  if ((quadratic_double (double_ap, double_b, (double_c - double_D), double_xl).isValid) && (quadratic_double (double_ap, double_b, (double_c - double_D), double_xu).isValid))
  { struct maybeBool res;
    res = someBool((((double_xl - double_xu) <= - (double_E_0)) || (((((((double)(2) * double_ap) * double_xl) + double_b) <= - (double_E_1)) && (double_E_2 <= ((((double)(2) * double_ap) * double_xu) + double_b))) && (((double_b * double_b) - (((double)(4) * double_ap) * (double_c - double_D))) > double_E_3))) || ((quadratic_double (double_ap, double_b, (double_c - double_D), double_xl).value < - (double_E_4)) || (quadratic_double (double_ap, double_b, (double_c - double_D), double_xu).value < - (double_E_5))));
    return res;
  } else { return noneBool();
  }
}


/*@
ensures \forall real ap, real b, real c, real xl, real xu, real D; (-10000 <= ap && ap <= 10000 && -10000 <= b && b <= 10000 && -10000 <= c && c <= 10000 && 0 <= xl && xl <= 0 && 1 <= xu && xu <= 1 && 0 <= D && D <= 0 && \result.isValid && \abs(double_ap - ap) <= \ulp_dp(ap)/2 && \abs(double_b - b) <= \ulp_dp(b)/2 && \abs(double_c - c) <= \ulp_dp(c)/2 && \abs(double_xl - xl) <= \ulp_dp(xl)/2 && \abs(double_xu - xu) <= \ulp_dp(xu)/2 && \abs(double_D - D) <= \ulp_dp(D)/2)
        ==> (\result.value
             ==> (quad_min_le_D_int(ap, b, c, xl, xu, D))) ;
*/
struct maybeBool quad_min_le_D_int_tauplus_num (double double_ap, double double_b, double double_c, double double_xl, double double_xu, double double_D) {
  return quad_min_le_D_int_tauplus_bool (double_ap, double_b, double_c, double_xl, double_xu, double_D, 0x1.0000000000001p-52, 0x1.0000000000001p-39, 0x1.6e20000000001p-37, 0x1.ef90000000003p-23, 0x1.8000000000002p-39, 0x1.d530000000003p-37);
}
/*@
axiomatic real_pred_quad_min_le_D_int {
logic boolean quad_min_le_D_int (real ap, real b, real c, real xl, real xu, real D) =
(xl - xu) <= 0 || (((2 * ap) * xl) + b) <= 0 && 0 <= (((2 * ap) * xu) + b) && ((b * b) - ((4 * ap) * (c - D))) > 0 || quadratic(ap, b, (c - D), xl) < 0 || quadratic(ap, b, (c - D), xu) < 0;
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4 && 0 <= double_E_5 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (! quad_min_le_D_int(double_ap, double_b, double_c, double_xl, double_xu, double_D)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real ap, real b, real c, real xl, real xu, real D; (\abs(Dsub(double_xl, double_xu) - (xl - xu)) <= double_E_0 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), double_xl), double_b) - (((2 * ap) * xl) + b)) <= double_E_1 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), double_xu), double_b) - (((2 * ap) * xu) + b)) <= double_E_2 && \abs(Dsub(Dmul(double_b, double_b), Dmul(Dmul(round(4), double_ap), Dsub(double_c, double_D))) - ((b * b) - ((4 * ap) * (c - D)))) <= double_E_3 && \abs(quadratic(double_ap, double_b, Dsub(double_c, double_D), double_xl) - quadratic(ap, b, (c - D), xl)) <= double_E_4 && \abs(quadratic(double_ap, double_b, Dsub(double_c, double_D), double_xu) - quadratic(ap, b, (c - D), xu)) <= double_E_5
                                                                         ==> (quad_min_le_D_int_stable_paths(ap, b, c, xl, xu, D, double_ap, double_b, double_c, double_xl, double_xu, double_D)))) ;
*/
struct maybeBool quad_min_le_D_int_tauminus_bool (double double_ap, double double_b, double double_c, double double_xl, double double_xu, double double_D, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4, double double_E_5) {
  if ((quadratic_double (double_ap, double_b, (double_c - double_D), double_xl).isValid) && (quadratic_double (double_ap, double_b, (double_c - double_D), double_xu).isValid))
  { struct maybeBool res;
    res = someBool((((double_xl - double_xu) > double_E_0) && (((((((double)(2) * double_ap) * double_xl) + double_b) > double_E_1) || (- (double_E_2) > ((((double)(2) * double_ap) * double_xu) + double_b))) || (((double_b * double_b) - (((double)(4) * double_ap) * (double_c - double_D))) <= - (double_E_3)))) && ((quadratic_double (double_ap, double_b, (double_c - double_D), double_xl).value >= double_E_4) && (quadratic_double (double_ap, double_b, (double_c - double_D), double_xu).value >= double_E_5)));
    return res;
  } else { return noneBool();
  }
}


/*@
ensures \forall real ap, real b, real c, real xl, real xu, real D; (-10000 <= ap && ap <= 10000 && -10000 <= b && b <= 10000 && -10000 <= c && c <= 10000 && 0 <= xl && xl <= 0 && 1 <= xu && xu <= 1 && 0 <= D && D <= 0 && \result.isValid && \abs(double_ap - ap) <= \ulp_dp(ap)/2 && \abs(double_b - b) <= \ulp_dp(b)/2 && \abs(double_c - c) <= \ulp_dp(c)/2 && \abs(double_xl - xl) <= \ulp_dp(xl)/2 && \abs(double_xu - xu) <= \ulp_dp(xu)/2 && \abs(double_D - D) <= \ulp_dp(D)/2)
        ==> (\result.value
             ==> (! quad_min_le_D_int(ap, b, c, xl, xu, D))) ;
*/
struct maybeBool quad_min_le_D_int_tauminus_num (double double_ap, double double_b, double double_c, double double_xl, double double_xu, double double_D) {
  return quad_min_le_D_int_tauminus_bool (double_ap, double_b, double_c, double_xl, double_xu, double_D, 0x1.0000000000001p-52, 0x1.0000000000001p-39, 0x1.6e20000000001p-37, 0x1.ef90000000003p-23, 0x1.8000000000002p-39, 0x1.d530000000003p-37);
}
/*@
axiomatic real_pred_near_edge {
logic boolean near_edge (real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y) =
(\abs((s_x - segstart_x)) > 0 && \abs((s_x - segend_x)) > 0 && sign((s_x - segend_x)) == sign((s_x - segstart_x)))
? \false :
(\abs((s_y - segstart_y)) > 0 && \abs((s_y - segend_y)) > 0 && sign((s_y - segend_y)) == sign((s_y - segstart_y)))
? \false :
\let length_x = (segend_x - segstart_x) ;
(\let length_y = (segend_y - segstart_y) ;
 (\let ap = ((length_x * length_x) + (length_y * length_y)) ;
  (\let diffstart_x = (segstart_x - s_x) ;
   (\let diffstart_y = (segstart_y - s_y) ;
    (\let diffend_x = (segend_x - s_x) ;
     (\let diffend_y = (segend_y - s_y) ;
      (\let b = (2 * ((diffstart_x * length_x) + (diffstart_y * length_y))) ;
       (\let c = ((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y)) ;
        (((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y)) < 0 || ((diffend_x * diffend_x) + (diffend_y * diffend_y)) < 0 || ap > 0 && quad_min_le_D_int(ap, b, c, 0, 1, 0))))))))));
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4 && 0 <= double_E_5 && 0 <= double_E_6 && 0 <= double_E_7 && 0 <= double_E_8 && 0 <= double_E_9 && 0 <= double_E_10 && 0 <= double_E_11 && 0 <= double_E_12 && 0 <= double_E_13 && 0 <= double_E_14 && 0 <= double_E_15 && 0 <= double_E_16 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (near_edge(double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y; (\abs(Dabs(Dsub(double_s_x, double_segstart_x)) - \abs((s_x - segstart_x))) <= double_E_0 && \abs(Dabs(Dsub(double_s_x, double_segend_x)) - \abs((s_x - segend_x))) <= double_E_1 && \abs(Dsub(double_s_x, double_segend_x) - (s_x - segend_x)) <= double_E_2 && \abs(Dsub(double_s_x, double_segstart_x) - (s_x - segstart_x)) <= double_E_3 && \abs(Dabs(Dsub(double_s_y, double_segstart_y)) - \abs((s_y - segstart_y))) <= double_E_4 && \abs(Dabs(Dsub(double_s_y, double_segend_y)) - \abs((s_y - segend_y))) <= double_E_5 && \abs(Dsub(double_s_y, double_segend_y) - (s_y - segend_y)) <= double_E_6 && \abs(Dsub(double_s_y, double_segstart_y) - (s_y - segstart_y)) <= double_E_7 && \abs(Dadd(Dmul(double_diffstart_x, double_diffstart_x), Dmul(double_diffstart_y, double_diffstart_y)) - ((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y))) <= double_E_8 && \abs(Dadd(Dmul(double_diffend_x, double_diffend_x), Dmul(double_diffend_y, double_diffend_y)) - ((diffend_x * diffend_x) + (diffend_y * diffend_y))) <= double_E_9 && \abs(double_ap - ap) <= double_E_10 && \abs(Dsub(0, 1) - (0 - 1)) <= double_E_11 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), 0), double_b) - (((2 * ap) * 0) + b)) <= double_E_12 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), 1), double_b) - (((2 * ap) * 1) + b)) <= double_E_13 && \abs(Dsub(Dmul(double_b, double_b), Dmul(Dmul(round(4), double_ap), Dsub(double_c, 0))) - ((b * b) - ((4 * ap) * (c - 0)))) <= double_E_14 && \abs(quadratic(double_ap, double_b, Dsub(double_c, 0), 0) - quadratic(ap, b, (c - 0), 0)) <= double_E_15 && \abs(quadratic(double_ap, double_b, Dsub(double_c, 0), 1) - quadratic(ap, b, (c - 0), 1)) <= double_E_16
                                                                                                          ==> (near_edge_stable_paths(segstart_x, segstart_y, segend_x, segend_y, s_x, s_y, double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y)))) ;
*/
struct maybeBool near_edge_tauplus_bool (double double_segstart_x, double double_segstart_y, double double_segend_x, double double_segend_y, double double_s_x, double double_s_y, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4, double double_E_5, double double_E_6, double double_E_7, double double_E_8, double double_E_9, double double_E_10, double double_E_11, double double_E_12, double double_E_13, double double_E_14, double double_E_15, double double_E_16) {
  if ((((sign_int ((double_s_y - double_segend_y), double_E_6).isValid) && (sign_int ((double_s_y - double_segstart_y), double_E_7).isValid)) && (sign_int ((double_s_x - double_segend_x), double_E_2).isValid)) && (sign_int ((double_s_x - double_segstart_x), double_E_3).isValid))
  { struct maybeBool res;
    struct maybeInt aux_0 = sign_int ((double_s_y - double_segend_y), double_E_6);
    struct maybeInt aux_1 = sign_int ((double_s_y - double_segstart_y), double_E_7);
    struct maybeInt aux_2 = sign_int ((double_s_x - double_segend_x), double_E_2);
    struct maybeInt aux_3 = sign_int ((double_s_x - double_segstart_x), double_E_3);
    if ((((aux_0.isValid) && (aux_1.isValid)) && (aux_2.isValid)) && (aux_3.isValid))
    { if (((fabs((double_s_x - double_segstart_x)) > double_E_0) && (fabs((double_s_x - double_segend_x)) > double_E_1)) && (aux_2.value == aux_3.value))
      { res = someBool(false);;
      }
      else if ((((fabs((double_s_y - double_segstart_y)) > double_E_4) && (fabs((double_s_y - double_segend_y)) > double_E_5)) && (aux_0.value == aux_1.value)) && (((fabs((double_s_x - double_segstart_x)) <= - (double_E_0)) || (fabs((double_s_x - double_segend_x)) <= - (double_E_1))) || (aux_2.value == aux_3.value)))
      { res = someBool(false);; }
      else if ((((fabs((double_s_y - double_segstart_y)) <= - (double_E_4)) || (fabs((double_s_y - double_segend_y)) <= - (double_E_5))) || (aux_0.value == aux_1.value)) && (((fabs((double_s_x - double_segstart_x)) <= - (double_E_0)) || (fabs((double_s_x - double_segend_x)) <= - (double_E_1))) || (aux_2.value == aux_3.value)))
      { double double_length_x = (double_segend_x - double_segstart_x);;
        double double_length_y = (double_segend_y - double_segstart_y);;
        double double_ap = ((double_length_x * double_length_x) + (double_length_y * double_length_y));;
        double double_diffstart_x = (double_segstart_x - double_s_x);;
        double double_diffstart_y = (double_segstart_y - double_s_y);;
        double double_diffend_x = (double_segend_x - double_s_x);;
        double double_diffend_y = (double_segend_y - double_s_y);;
        double double_b = ((double)(2) * ((double_diffstart_x * double_length_x) + (double_diffstart_y * double_length_y)));;
        double double_c = ((double_diffstart_x * double_diffstart_x) + (double_diffstart_y * double_diffstart_y));;
        res = someBool(((((double_diffstart_x * double_diffstart_x) + (double_diffstart_y * double_diffstart_y)) < - (double_E_8)) || (((double_diffend_x * double_diffend_x) + (double_diffend_y * double_diffend_y)) < - (double_E_9))) || ((double_ap > double_E_10) && (quad_min_le_D_int_tauplus_bool(double_ap, double_b, double_c, 0, 1, 0, double_E_11, double_E_12, double_E_13, double_E_14, double_E_15, double_E_16).value)));; }
      else { res = noneBool();
      }
    } else { res = noneBool();
    }
    return res;
  } else { return noneBool();
  }
}


/*@
ensures \forall real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y; (-10000 <= segstart_x && segstart_x <= 10000 && -10000 <= segstart_y && segstart_y <= 10000 && -10000 <= segend_x && segend_x <= 10000 && -10000 <= segend_y && segend_y <= 10000 && -10000 <= s_x && s_x <= 10000 && -10000 <= s_y && s_y <= 10000 && \result.isValid && \abs(double_segstart_x - segstart_x) <= \ulp_dp(segstart_x)/2 && \abs(double_segstart_y - segstart_y) <= \ulp_dp(segstart_y)/2 && \abs(double_segend_x - segend_x) <= \ulp_dp(segend_x)/2 && \abs(double_segend_y - segend_y) <= \ulp_dp(segend_y)/2 && \abs(double_s_x - s_x) <= \ulp_dp(s_x)/2 && \abs(double_s_y - s_y) <= \ulp_dp(s_y)/2)
        ==> (\result.value
             ==> (near_edge(segstart_x, segstart_y, segend_x, segend_y, s_x, s_y))) ;
*/
struct maybeBool near_edge_tauplus_num (double double_segstart_x, double double_segstart_y, double double_segend_x, double double_segend_y, double double_s_x, double double_s_y) {
  return near_edge_tauplus_bool (double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1.b880000000001p-22, 0x1.b880000000001p-22, 0x1.b880000000001p-22, 0x1p-53, 0x1.1c40000000001p-20, 0x1.1c40000000001p-19, 0x1.a7e1bd1000003p12, 0x1.1c40000000001p-21, 0x1.3440000000002p-19);
}
/*@
axiomatic real_pred_near_edge {
logic boolean near_edge (real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y) =
(\abs((s_x - segstart_x)) > 0 && \abs((s_x - segend_x)) > 0 && sign((s_x - segend_x)) == sign((s_x - segstart_x)))
? \false :
(\abs((s_y - segstart_y)) > 0 && \abs((s_y - segend_y)) > 0 && sign((s_y - segend_y)) == sign((s_y - segstart_y)))
? \false :
\let length_x = (segend_x - segstart_x) ;
(\let length_y = (segend_y - segstart_y) ;
 (\let ap = ((length_x * length_x) + (length_y * length_y)) ;
  (\let diffstart_x = (segstart_x - s_x) ;
   (\let diffstart_y = (segstart_y - s_y) ;
    (\let diffend_x = (segend_x - s_x) ;
     (\let diffend_y = (segend_y - s_y) ;
      (\let b = (2 * ((diffstart_x * length_x) + (diffstart_y * length_y))) ;
       (\let c = ((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y)) ;
        (((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y)) < 0 || ((diffend_x * diffend_x) + (diffend_y * diffend_y)) < 0 || ap > 0 && quad_min_le_D_int(ap, b, c, 0, 1, 0))))))))));
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4 && 0 <= double_E_5 && 0 <= double_E_6 && 0 <= double_E_7 && 0 <= double_E_8 && 0 <= double_E_9 && 0 <= double_E_10 && 0 <= double_E_11 && 0 <= double_E_12 && 0 <= double_E_13 && 0 <= double_E_14 && 0 <= double_E_15 && 0 <= double_E_16 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (! near_edge(double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y; (\abs(Dabs(Dsub(double_s_x, double_segstart_x)) - \abs((s_x - segstart_x))) <= double_E_0 && \abs(Dabs(Dsub(double_s_x, double_segend_x)) - \abs((s_x - segend_x))) <= double_E_1 && \abs(Dsub(double_s_x, double_segend_x) - (s_x - segend_x)) <= double_E_2 && \abs(Dsub(double_s_x, double_segstart_x) - (s_x - segstart_x)) <= double_E_3 && \abs(Dabs(Dsub(double_s_y, double_segstart_y)) - \abs((s_y - segstart_y))) <= double_E_4 && \abs(Dabs(Dsub(double_s_y, double_segend_y)) - \abs((s_y - segend_y))) <= double_E_5 && \abs(Dsub(double_s_y, double_segend_y) - (s_y - segend_y)) <= double_E_6 && \abs(Dsub(double_s_y, double_segstart_y) - (s_y - segstart_y)) <= double_E_7 && \abs(Dadd(Dmul(double_diffstart_x, double_diffstart_x), Dmul(double_diffstart_y, double_diffstart_y)) - ((diffstart_x * diffstart_x) + (diffstart_y * diffstart_y))) <= double_E_8 && \abs(Dadd(Dmul(double_diffend_x, double_diffend_x), Dmul(double_diffend_y, double_diffend_y)) - ((diffend_x * diffend_x) + (diffend_y * diffend_y))) <= double_E_9 && \abs(double_ap - ap) <= double_E_10 && \abs(Dsub(0, 1) - (0 - 1)) <= double_E_11 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), 0), double_b) - (((2 * ap) * 0) + b)) <= double_E_12 && \abs(Dadd(Dmul(Dmul(round(2), double_ap), 1), double_b) - (((2 * ap) * 1) + b)) <= double_E_13 && \abs(Dsub(Dmul(double_b, double_b), Dmul(Dmul(round(4), double_ap), Dsub(double_c, 0))) - ((b * b) - ((4 * ap) * (c - 0)))) <= double_E_14 && \abs(quadratic(double_ap, double_b, Dsub(double_c, 0), 0) - quadratic(ap, b, (c - 0), 0)) <= double_E_15 && \abs(quadratic(double_ap, double_b, Dsub(double_c, 0), 1) - quadratic(ap, b, (c - 0), 1)) <= double_E_16
                                                                                                          ==> (near_edge_stable_paths(segstart_x, segstart_y, segend_x, segend_y, s_x, s_y, double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y)))) ;
*/
struct maybeBool near_edge_tauminus_bool (double double_segstart_x, double double_segstart_y, double double_segend_x, double double_segend_y, double double_s_x, double double_s_y, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4, double double_E_5, double double_E_6, double double_E_7, double double_E_8, double double_E_9, double double_E_10, double double_E_11, double double_E_12, double double_E_13, double double_E_14, double double_E_15, double double_E_16) {
  if ((((sign_int ((double_s_y - double_segend_y), double_E_6).isValid) && (sign_int ((double_s_y - double_segstart_y), double_E_7).isValid)) && (sign_int ((double_s_x - double_segend_x), double_E_2).isValid)) && (sign_int ((double_s_x - double_segstart_x), double_E_3).isValid))
  { struct maybeBool res;
    struct maybeInt aux_0 = sign_int ((double_s_y - double_segend_y), double_E_6);
    struct maybeInt aux_1 = sign_int ((double_s_y - double_segstart_y), double_E_7);
    struct maybeInt aux_2 = sign_int ((double_s_x - double_segend_x), double_E_2);
    struct maybeInt aux_3 = sign_int ((double_s_x - double_segstart_x), double_E_3);
    if ((((aux_0.isValid) && (aux_1.isValid)) && (aux_2.isValid)) && (aux_3.isValid))
    { if (((fabs((double_s_x - double_segstart_x)) > double_E_0) && (fabs((double_s_x - double_segend_x)) > double_E_1)) && (aux_2.value == aux_3.value))
      { res = someBool(true);;
      }
      else if ((((fabs((double_s_y - double_segstart_y)) > double_E_4) && (fabs((double_s_y - double_segend_y)) > double_E_5)) && (aux_0.value == aux_1.value)) && (((fabs((double_s_x - double_segstart_x)) <= - (double_E_0)) || (fabs((double_s_x - double_segend_x)) <= - (double_E_1))) || (aux_2.value == aux_3.value)))
      { res = someBool(true);; }
      else if ((((fabs((double_s_y - double_segstart_y)) <= - (double_E_4)) || (fabs((double_s_y - double_segend_y)) <= - (double_E_5))) || (aux_0.value == aux_1.value)) && (((fabs((double_s_x - double_segstart_x)) <= - (double_E_0)) || (fabs((double_s_x - double_segend_x)) <= - (double_E_1))) || (aux_2.value == aux_3.value)))
      { double double_length_x = (double_segend_x - double_segstart_x);;
        double double_length_y = (double_segend_y - double_segstart_y);;
        double double_ap = ((double_length_x * double_length_x) + (double_length_y * double_length_y));;
        double double_diffstart_x = (double_segstart_x - double_s_x);;
        double double_diffstart_y = (double_segstart_y - double_s_y);;
        double double_diffend_x = (double_segend_x - double_s_x);;
        double double_diffend_y = (double_segend_y - double_s_y);;
        double double_b = ((double)(2) * ((double_diffstart_x * double_length_x) + (double_diffstart_y * double_length_y)));;
        double double_c = ((double_diffstart_x * double_diffstart_x) + (double_diffstart_y * double_diffstart_y));;
        res = someBool(((((double_diffstart_x * double_diffstart_x) + (double_diffstart_y * double_diffstart_y)) >= double_E_8) && (((double_diffend_x * double_diffend_x) + (double_diffend_y * double_diffend_y)) >= double_E_9)) && ((double_ap <= - (double_E_10)) || (quad_min_le_D_int_tauminus_bool(double_ap, double_b, double_c, 0, 1, 0, double_E_11, double_E_12, double_E_13, double_E_14, double_E_15, double_E_16).value)));; }
      else { res = noneBool();
      }
    } else { res = noneBool();
    }
    return res;
  } else { return noneBool();
  }
}


/*@
ensures \forall real segstart_x, real segstart_y, real segend_x, real segend_y, real s_x, real s_y; (-10000 <= segstart_x && segstart_x <= 10000 && -10000 <= segstart_y && segstart_y <= 10000 && -10000 <= segend_x && segend_x <= 10000 && -10000 <= segend_y && segend_y <= 10000 && -10000 <= s_x && s_x <= 10000 && -10000 <= s_y && s_y <= 10000 && \result.isValid && \abs(double_segstart_x - segstart_x) <= \ulp_dp(segstart_x)/2 && \abs(double_segstart_y - segstart_y) <= \ulp_dp(segstart_y)/2 && \abs(double_segend_x - segend_x) <= \ulp_dp(segend_x)/2 && \abs(double_segend_y - segend_y) <= \ulp_dp(segend_y)/2 && \abs(double_s_x - s_x) <= \ulp_dp(s_x)/2 && \abs(double_s_y - s_y) <= \ulp_dp(s_y)/2)
        ==> (\result.value
             ==> (! near_edge(segstart_x, segstart_y, segend_x, segend_y, s_x, s_y))) ;
*/
struct maybeBool near_edge_tauminus_num (double double_segstart_x, double double_segstart_y, double double_segend_x, double double_segend_y, double double_s_x, double double_s_y) {
  return near_edge_tauminus_bool (double_segstart_x, double_segstart_y, double_segend_x, double_segend_y, double_s_x, double_s_y, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1p-38, 0x1.b880000000001p-22, 0x1.b880000000001p-22, 0x1.b880000000001p-22, 0x1p-53, 0x1.1c40000000001p-20, 0x1.1c40000000001p-19, 0x1.a7e1bd1000003p12, 0x1.1c40000000001p-21, 0x1.3440000000002p-19);
}


int main () { return 0; }