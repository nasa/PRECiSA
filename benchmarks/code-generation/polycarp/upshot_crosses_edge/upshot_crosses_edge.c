// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"


/*@
axiomatic real_pred_not_upshot_crosses_edge {
logic boolean not_upshot_crosses_edge (integer N, real *Px, real *Py, real Sx, real Sy, integer i) =
i < (N - 1) ? ((Px[i] - Px[(i + 1)]) != 0 || (Py[i] - Sy) < 0 || (Py[(i + 1)] - Sy) < 0 && ((\pow ((Px[(i + 1)] - Px[i]) , 2) * (Py[i] - Sy)) + (((Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i]))) < 0) : ((Px[N] - Px[0]) != 0 || (Py[N] - Sy) < 0 || (Py[0] - Sy) < 0 && ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N]))) < 0);
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (not_upshot_crosses_edge(N, Px, Py, double_Sx, double_Sy, i)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real Sx, real Sy; (\abs(Dsub(Px[i], Px[Iadd(i, 1)]) - (Px[i] - Px[(i + 1)])) <= double_E_0 && \abs(Dsub(Py[i], double_Sy) - (Py[i] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[Iadd(i, 1)], Px[i]) ^ (round(2)), Dsub(Py[i], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[i]), Dsub(Py[Iadd(i, 1)], Py[i])), Dsub(Px[Iadd(i, 1)], Px[i]))) - ((\pow ((Px[(i + 1)] - Px[i]) , 2) * (Py[i] - Sy)) + (((Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i])))) <= double_E_2 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[0], Px[N]) ^ (round(2)), Dsub(Py[N], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[N]), Dsub(Py[0], Py[N])), Dsub(Px[0], Px[N]))) - ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N])))) <= double_E_2 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[0], Px[N]) ^ (round(2)), Dsub(Py[N], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[N]), Dsub(Py[0], Py[N])), Dsub(Px[0], Px[N]))) - ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N])))) <= double_E_2
                                        ==> (not_upshot_crosses_edge_stable_paths(Sx, Sy, N, double_Px, double_Py, double_Sx, double_Sy, i)))) ;
*/
struct maybeBool not_upshot_crosses_edge_tauplus_bool (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i, double double_E_0, double double_E_1, double double_E_2) {
  struct maybeBool res;
  if (true)
  { res = someBool(((((Px[i] - Px[(i + 1)]) > double_E_0) || ((Px[i] - Px[(i + 1)]) < - (double_E_0))) || (((Py[i] - double_Sy) < - (double_E_1)) || ((Py[(i + 1)] - double_Sy) < - (double_E_1)))) && (((pow((Px[(i + 1)] - Px[i]) , (double)(2)) * (Py[i] - double_Sy)) + (((double_Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i]))) < - (double_E_2)));
  } else { res = someBool(((((Px[N] - Px[0]) > double_E_0) || ((Px[N] - Px[0]) < - (double_E_0))) || (((Py[N] - double_Sy) < - (double_E_1)) || ((Py[0] - double_Sy) < - (double_E_1)))) && (((pow((Px[0] - Px[N]) , (double)(2)) * (Py[N] - double_Sy)) + (((double_Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N]))) < - (double_E_2)));
  }
  return res;
}


/*@
ensures \forall integer N, real * Px, real * Py, real Sx, real Sy, integer i; (1 <= N && N <= 20 && -10000 <= Px && Px <= 10000 && -10000 <= Py && Py <= 10000 && -10000 <= Sx && Sx <= 10000 && -10000 <= Sy && Sy <= 10000 && 1 <= i && i <= 20 && \result.isValid && \abs(double_Px - Px) <= \ulp_dp(Px)/2 && \abs(double_Py - Py) <= \ulp_dp(Py)/2 && \abs(double_Sx - Sx) <= \ulp_dp(Sx)/2 && \abs(double_Sy - Sy) <= \ulp_dp(Sy)/2)
        ==> (\result.value
             ==> (not_upshot_crosses_edge(N, Px, Py, Sx, Sy, i))) ;
*/
struct maybeBool not_upshot_crosses_edge_tauplus_num (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i) {
  return not_upshot_crosses_edge_tauplus_bool (N, Px, Py, double_Sx, double_Sy, i, 0x1.0000000000001p-39, 0x1p-38, 0x1.3880000000009p-63);
}
/*@
axiomatic real_pred_not_upshot_crosses_edge {
logic boolean not_upshot_crosses_edge (integer N, real *Px, real *Py, real Sx, real Sy, integer i) =
i < (N - 1) ? ((Px[i] - Px[(i + 1)]) != 0 || (Py[i] - Sy) < 0 || (Py[(i + 1)] - Sy) < 0 && ((\pow ((Px[(i + 1)] - Px[i]) , 2) * (Py[i] - Sy)) + (((Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i]))) < 0) : ((Px[N] - Px[0]) != 0 || (Py[N] - Sy) < 0 || (Py[0] - Sy) < 0 && ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N]))) < 0);
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (! not_upshot_crosses_edge(N, Px, Py, double_Sx, double_Sy, i)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real Sx, real Sy; (\abs(Dsub(Px[i], Px[Iadd(i, 1)]) - (Px[i] - Px[(i + 1)])) <= double_E_0 && \abs(Dsub(Py[i], double_Sy) - (Py[i] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[Iadd(i, 1)], Px[i]) ^ (round(2)), Dsub(Py[i], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[i]), Dsub(Py[Iadd(i, 1)], Py[i])), Dsub(Px[Iadd(i, 1)], Px[i]))) - ((\pow ((Px[(i + 1)] - Px[i]) , 2) * (Py[i] - Sy)) + (((Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i])))) <= double_E_2 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[0], Px[N]) ^ (round(2)), Dsub(Py[N], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[N]), Dsub(Py[0], Py[N])), Dsub(Px[0], Px[N]))) - ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N])))) <= double_E_2 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dadd(Dmul(Dsub(Px[0], Px[N]) ^ (round(2)), Dsub(Py[N], double_Sy)), Dmul(Dmul(Dsub(double_Sx, Px[N]), Dsub(Py[0], Py[N])), Dsub(Px[0], Px[N]))) - ((\pow ((Px[0] - Px[N]) , 2) * (Py[N] - Sy)) + (((Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N])))) <= double_E_2
                                        ==> (not_upshot_crosses_edge_stable_paths(Sx, Sy, N, double_Px, double_Py, double_Sx, double_Sy, i)))) ;
*/
struct maybeBool not_upshot_crosses_edge_tauminus_bool (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i, double double_E_0, double double_E_1, double double_E_2) {
  struct maybeBool res;
  if (true)
  { res = someBool(((((Px[i] - Px[(i + 1)]) <= - (double_E_0)) && ((Px[i] - Px[(i + 1)]) >= double_E_0)) && (((Py[i] - double_Sy) >= double_E_1) && ((Py[(i + 1)] - double_Sy) >= double_E_1))) || (((pow((Px[(i + 1)] - Px[i]) , (double)(2)) * (Py[i] - double_Sy)) + (((double_Sx - Px[i]) * (Py[(i + 1)] - Py[i])) * (Px[(i + 1)] - Px[i]))) >= double_E_2));
  } else { res = someBool(((((Px[N] - Px[0]) <= - (double_E_0)) && ((Px[N] - Px[0]) >= double_E_0)) && (((Py[N] - double_Sy) >= double_E_1) && ((Py[0] - double_Sy) >= double_E_1))) || (((pow((Px[0] - Px[N]) , (double)(2)) * (Py[N] - double_Sy)) + (((double_Sx - Px[N]) * (Py[0] - Py[N])) * (Px[0] - Px[N]))) >= double_E_2));
  }
  return res;
}


/*@
ensures \forall integer N, real * Px, real * Py, real Sx, real Sy, integer i; (1 <= N && N <= 20 && -10000 <= Px && Px <= 10000 && -10000 <= Py && Py <= 10000 && -10000 <= Sx && Sx <= 10000 && -10000 <= Sy && Sy <= 10000 && 1 <= i && i <= 20 && \result.isValid && \abs(double_Px - Px) <= \ulp_dp(Px)/2 && \abs(double_Py - Py) <= \ulp_dp(Py)/2 && \abs(double_Sx - Sx) <= \ulp_dp(Sx)/2 && \abs(double_Sy - Sy) <= \ulp_dp(Sy)/2)
        ==> (\result.value
             ==> (! not_upshot_crosses_edge(N, Px, Py, Sx, Sy, i))) ;
*/
struct maybeBool not_upshot_crosses_edge_tauminus_num (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i) {
  return not_upshot_crosses_edge_tauminus_bool (N, Px, Py, double_Sx, double_Sy, i, 0x1.0000000000001p-39, 0x1p-38, 0x1.3880000000009p-63);
}
/*@
axiomatic real_pred_upshot_crosses_edge_valid {
logic boolean upshot_crosses_edge_valid (integer N, real *Px, real *Py, real Sx, real Sy, integer i) =
i < (N - 1) ? ((Px[i] - Px[(i + 1)]) != 0 || (Py[i] - Sy) < 0 && (Py[(i + 1)] - Sy) < 0) : ((Px[N] - Px[0]) != 0 || (Py[N] - Sy) < 0 && (Py[0] - Sy) < 0);
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (upshot_crosses_edge_valid(N, Px, Py, double_Sx, double_Sy, i)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real Sx, real Sy; (\abs(Dsub(Px[i], Px[Iadd(i, 1)]) - (Px[i] - Px[(i + 1)])) <= double_E_0 && \abs(Dsub(Py[i], double_Sy) - (Py[i] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1
                                        ==> (upshot_crosses_edge_valid_stable_paths(Sx, Sy, N, double_Px, double_Py, double_Sx, double_Sy, i)))) ;
*/
struct maybeBool upshot_crosses_edge_valid_tauplus_bool (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i, double double_E_0, double double_E_1) {
  struct maybeBool res;
  if (true)
  { res = someBool((((Px[i] - Px[(i + 1)]) > double_E_0) || ((Px[i] - Px[(i + 1)]) < - (double_E_0))) || (((Py[i] - double_Sy) < - (double_E_1)) && ((Py[(i + 1)] - double_Sy) < - (double_E_1))));
  } else { res = someBool((((Px[N] - Px[0]) > double_E_0) || ((Px[N] - Px[0]) < - (double_E_0))) || (((Py[N] - double_Sy) < - (double_E_1)) && ((Py[0] - double_Sy) < - (double_E_1))));
  }
  return res;
}


/*@
ensures \forall integer N, real * Px, real * Py, real Sx, real Sy, integer i; (1 <= N && N <= 20 && -10000 <= Px && Px <= 10000 && -10000 <= Py && Py <= 10000 && -10000 <= Sx && Sx <= 10000 && -10000 <= Sy && Sy <= 10000 && 1 <= i && i <= 20 && \result.isValid && \abs(double_Px - Px) <= \ulp_dp(Px)/2 && \abs(double_Py - Py) <= \ulp_dp(Py)/2 && \abs(double_Sx - Sx) <= \ulp_dp(Sx)/2 && \abs(double_Sy - Sy) <= \ulp_dp(Sy)/2)
        ==> (\result.value
             ==> (upshot_crosses_edge_valid(N, Px, Py, Sx, Sy, i))) ;
*/
struct maybeBool upshot_crosses_edge_valid_tauplus_num (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i) {
  return upshot_crosses_edge_valid_tauplus_bool (N, Px, Py, double_Sx, double_Sy, i, 0x1.0000000000001p-39, 0x1p-38);
}
/*@
axiomatic real_pred_upshot_crosses_edge_valid {
logic boolean upshot_crosses_edge_valid (integer N, real *Px, real *Py, real Sx, real Sy, integer i) =
i < (N - 1) ? ((Px[i] - Px[(i + 1)]) != 0 || (Py[i] - Sy) < 0 && (Py[(i + 1)] - Sy) < 0) : ((Px[N] - Px[0]) != 0 || (Py[N] - Sy) < 0 && (Py[0] - Sy) < 0);
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 ;
assigns \nothing;

behavior structure:
ensures \result.value
        ==> (! upshot_crosses_edge_valid(N, Px, Py, double_Sx, double_Sy, i)) ;

behavior stable_paths:
ensures \result.isValid
        ==> (\forall real Sx, real Sy; (\abs(Dsub(Px[i], Px[Iadd(i, 1)]) - (Px[i] - Px[(i + 1)])) <= double_E_0 && \abs(Dsub(Py[i], double_Sy) - (Py[i] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1 && \abs(Dsub(Py[Iadd(i, 1)], double_Sy) - (Py[(i + 1)] - Sy)) <= double_E_1 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Px[N], Px[0]) - (Px[N] - Px[0])) <= double_E_0 && \abs(Dsub(Py[N], double_Sy) - (Py[N] - Sy)) <= double_E_1 && \abs(Dsub(Py[0], double_Sy) - (Py[0] - Sy)) <= double_E_1
                                        ==> (upshot_crosses_edge_valid_stable_paths(Sx, Sy, N, double_Px, double_Py, double_Sx, double_Sy, i)))) ;
*/
struct maybeBool upshot_crosses_edge_valid_tauminus_bool (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i, double double_E_0, double double_E_1) {
  struct maybeBool res;
  if (true)
  { res = someBool((((Px[i] - Px[(i + 1)]) <= - (double_E_0)) && ((Px[i] - Px[(i + 1)]) >= double_E_0)) && (((Py[i] - double_Sy) >= double_E_1) || ((Py[(i + 1)] - double_Sy) >= double_E_1)));
  } else { res = someBool((((Px[N] - Px[0]) <= - (double_E_0)) && ((Px[N] - Px[0]) >= double_E_0)) && (((Py[N] - double_Sy) >= double_E_1) || ((Py[0] - double_Sy) >= double_E_1)));
  }
  return res;
}


/*@
ensures \forall integer N, real * Px, real * Py, real Sx, real Sy, integer i; (1 <= N && N <= 20 && -10000 <= Px && Px <= 10000 && -10000 <= Py && Py <= 10000 && -10000 <= Sx && Sx <= 10000 && -10000 <= Sy && Sy <= 10000 && 1 <= i && i <= 20 && \result.isValid && \abs(double_Px - Px) <= \ulp_dp(Px)/2 && \abs(double_Py - Py) <= \ulp_dp(Py)/2 && \abs(double_Sx - Sx) <= \ulp_dp(Sx)/2 && \abs(double_Sy - Sy) <= \ulp_dp(Sy)/2)
        ==> (\result.value
             ==> (! upshot_crosses_edge_valid(N, Px, Py, Sx, Sy, i))) ;
*/
struct maybeBool upshot_crosses_edge_valid_tauminus_num (int N, double *Px, double *Py, double double_Sx, double double_Sy, int i) {
  return upshot_crosses_edge_valid_tauminus_bool (N, Px, Py, double_Sx, double_Sy, i, 0x1.0000000000001p-39, 0x1p-38);
}


int main () { return 0; }