// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_simple {
logic real simple (real X, real Y) =
(X >= 0) ? ((X + Y)) : ((X * Y));
}
*/


/*@
axiomatic fp_function_simple {
logic double fp_simple (double X_double, double Y_double) =
(X_double >= (double) (0)) ? (Dadd(X_double, Y_double)) : (Dmul(X_double, Y_double));
}
*/


/*@ axiomatic simple_trans {
predicate simple_stable_paths (real X, real Y, double X_double, double Y_double) =
((! ((X >= 0)) && ! ((X_double >= (double) (0)))) || ((X >= 0) && (X_double >= (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_simple(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; ((\abs(X_double - X) <= E_0_double
                                        ==> (simple_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeDouble simple_double (double X_double, double Y_double, double E_0_double) {
  struct maybeDouble res;
  if (X_double >= E_0_double)
  { res = someDouble((X_double + Y_double));
  } else { if (X_double < - (E_0_double))
           { res = someDouble((X_double * Y_double));
           } else { res = noneDouble();
           }
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-50000 <= Y) && (Y <= 50000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - simple(X, Y))) <= 0x1.56d8000000001p-21))) ;
*/
struct maybeDouble simple_num (double X_double, double Y_double) {
  return simple_double (X_double, Y_double, 0x1p-38);
}


int main () { return 0; }