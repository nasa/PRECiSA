// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real sx, real vx) =
(sx < 0) ? ((sx + vx)) : ((sx - vx));
}
*/


/*@
axiomatic fp_function_f {
logic double fp_f (double sx_double, double vx_double) =
(sx_double < (double) (0)) ? (Dadd(sx_double, vx_double)) : (Dsub(sx_double, vx_double));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real sx, real vx, double sx_double, double vx_double) =
((! ((sx < 0)) && ! ((sx_double < (double) (0)))) || ((sx < 0) && (sx_double < (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(sx_double, vx_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; ((\abs(sx_double - sx) <= E_0_double
                                          ==> (f_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeDouble f_double (double sx_double, double vx_double, double E_0_double) {
  struct maybeDouble res;
  if (sx_double < - (E_0_double))
  { res = someDouble((sx_double + vx_double));
  } else { if (sx_double >= E_0_double)
           { res = someDouble((sx_double - vx_double));
           } else { res = noneDouble();
           }
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\abs((\result.value - f(sx, vx))) <= 0x1p-42))) ;
*/
struct maybeDouble f_num (double sx_double, double vx_double) {
  return f_double (sx_double, vx_double, 0x1p-44);
}


/*@
axiomatic real_pred_g {
logic boolean g (real sx, real vx) =
\let y = f(sx, vx) ;
((y < 0));
}
*/


/*@
axiomatic fp_pred_g {
logic boolean fp_g (double sx_double, double vx_double) =
\let y_double = fp_f(sx_double, vx_double) ;
((y_double < (double) (0)));
}
*/


/*@ axiomatic g_tauplus_trans {
predicate g_tauplus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
((((! ((sx < 0)) && ! ((sx_double < (double) (0)))) || ((sx < 0) && (sx_double < (double) (0)))) || (! ((sx < 0)) && ! ((sx_double < (double) (0))))) || ((sx < 0) && (sx_double < (double) (0))));
}
*/


/*@
requires (((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; ((((\abs(sx_double - sx) <= E_0_double && \let y_double = fp_f(sx_double, vx_double);
                                                                            \let y = f(sx, vx);
                                                                            \abs(y_double - y) <= E_1_double) && \let y_double = fp_f(sx_double, vx_double);
                                                                                                                 \let y = f(sx, vx);
                                                                                                                 \abs(y_double - y) <= E_2_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((g(sx, vx) && fp_g(sx_double, vx_double))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; ((((\abs(sx_double - sx) <= E_0_double && \let y_double = fp_f(sx_double, vx_double);
                                                                                  \let y = f(sx, vx);
                                                                                  \abs(y_double - y) <= E_1_double) && \let y_double = fp_f(sx_double, vx_double);
                                                                                                                       \let y = f(sx, vx);
                                                                                                                       \abs(y_double - y) <= E_2_double)
                                          ==> (g_tauplus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool g_tauplus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double, double E_2_double) {
  struct maybeBool res;
  struct maybeDouble aux_0 = f_double (sx_double, vx_double, E_0_double);
  if (aux_0.isValid)
  { double y_double = aux_0.value;
    res = someBool(y_double < - (E_1_double));
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (g(sx, vx))))) ;
*/
struct maybeBool g_tauplus_num (double sx_double, double vx_double) {
  return g_tauplus_bool (sx_double, vx_double, 0x1p-44, 0x1p-42, 0x1p-42);
}




/*@ axiomatic g_tauminus_trans {
predicate g_tauminus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
((((! ((sx < 0)) && ! ((sx_double < (double) (0)))) || ((sx < 0) && (sx_double < (double) (0)))) || (! ((sx < 0)) && ! ((sx_double < (double) (0))))) || ((sx < 0) && (sx_double < (double) (0))));
}
*/


/*@
requires (((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; ((((\abs(sx_double - sx) <= E_0_double && \let y_double = fp_f(sx_double, vx_double);
                                                                            \let y = f(sx, vx);
                                                                            \abs(y_double - y) <= E_1_double) && \let y_double = fp_f(sx_double, vx_double);
                                                                                                                 \let y = f(sx, vx);
                                                                                                                 \abs(y_double - y) <= E_2_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((! (g(sx, vx)) && ! (fp_g(sx_double, vx_double)))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; ((((\abs(sx_double - sx) <= E_0_double && \let y_double = fp_f(sx_double, vx_double);
                                                                                  \let y = f(sx, vx);
                                                                                  \abs(y_double - y) <= E_1_double) && \let y_double = fp_f(sx_double, vx_double);
                                                                                                                       \let y = f(sx, vx);
                                                                                                                       \abs(y_double - y) <= E_2_double)
                                          ==> (g_tauminus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool g_tauminus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double, double E_2_double) {
  struct maybeBool res;
  struct maybeDouble aux_0 = f_double (sx_double, vx_double, E_0_double);
  if (aux_0.isValid)
  { double y_double = aux_0.value;
    res = someBool(y_double >= E_2_double);
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (! (g(sx, vx)))))) ;
*/
struct maybeBool g_tauminus_num (double sx_double, double vx_double) {
  return g_tauminus_bool (sx_double, vx_double, 0x1p-44, 0x1p-42, 0x1p-42);
}


int main () { return 0; }