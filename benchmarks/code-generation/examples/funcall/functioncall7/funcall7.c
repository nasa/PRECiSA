// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real sx, real vx) =
\let t1 = (sx + vx) ;
((t1 <= 0) ? ((t1 + sx)) : ((t1 + vx)));
}
*/


/*@
axiomatic fp_function_f {
logic double fp_f (double sx_double, double vx_double) =
\let t1_double = Dadd(sx_double, vx_double) ;
((t1_double <= (double) (0)) ? (Dadd(t1_double, sx_double)) : (Dadd(t1_double, vx_double)));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real sx, real vx, double sx_double, double vx_double) =
((! (((sx + vx) <= 0)) && ! ((Dadd(sx_double, vx_double) <= (double) (0)))) || (((sx + vx) <= 0) && (Dadd(sx_double, vx_double) <= (double) (0))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(sx_double, vx_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((\let t1_double = Dadd(sx_double, vx_double);
                                           \let t1 = (sx + vx);
                                           \abs(t1_double - t1) <= E_0_double && \let t1_double = Dadd(sx_double, vx_double);
                                                                                 \let t1 = (sx + vx);
                                                                                 \abs(t1_double - t1) <= E_1_double)
                                          ==> (f_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeDouble f_double (double sx_double, double vx_double, double E_0_double, double E_1_double) {
  struct maybeDouble res;
  double t1_double = (sx_double + vx_double);
  if (t1_double <= - (E_0_double))
  { res = someDouble((t1_double + sx_double));
  } else { if (t1_double > E_1_double)
           { res = someDouble((t1_double + vx_double));
           } else { res = noneDouble();
           }
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\abs((\result.value - f(sx, vx))) <= 0x1.2p-41))) ;
*/
struct maybeDouble f_num (double sx_double, double vx_double) {
  return f_double (sx_double, vx_double, 0x1p-42, 0x1p-42);
}


/*@
axiomatic real_function_g {
logic real g (real sx, real vx) =
\let y = f(sx, vx) ;
((y + 2));
}
*/


/*@
axiomatic fp_function_g {
logic double fp_g (double sx_double, double vx_double) =
\let y_double = fp_f(sx_double, vx_double) ;
(Dadd(y_double, (double) (2)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real sx, real vx, double sx_double, double vx_double) =
((((! (((sx + vx) <= 0)) && ! ((Dadd(sx_double, vx_double) <= (double) (0)))) || (((sx + vx) <= 0) && (Dadd(sx_double, vx_double) <= (double) (0)))) || (! (((sx + vx) <= 0)) && ! ((Dadd(sx_double, vx_double) <= (double) (0))))) || (((sx + vx) <= 0) && (Dadd(sx_double, vx_double) <= (double) (0))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_g(sx_double, vx_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((\let t1_double = Dadd(sx_double, vx_double);
                                           \let t1 = (sx + vx);
                                           \abs(Dadd(sx_double, vx_double) - (sx + vx)) <= E_0_double && \let t1_double = Dadd(sx_double, vx_double);
                                                                                                         \let t1 = (sx + vx);
                                                                                                         \abs(Dadd(sx_double, vx_double) - (sx + vx)) <= E_1_double)
                                          ==> (g_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeDouble g_double (double sx_double, double vx_double, double E_0_double, double E_1_double) {
  struct maybeDouble res;
  struct maybeDouble aux_0 = f_double (sx_double, vx_double, E_0_double, E_1_double);
  if (aux_0.isValid)
  { double y_double = aux_0.value;
    res = someDouble((y_double + (double)(2)));
  } else { res = noneDouble();
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\abs((\result.value - g(sx, vx))) <= 0x1.ap-41))) ;
*/
struct maybeDouble g_num (double sx_double, double vx_double) {
  return g_double (sx_double, vx_double, 0x1p-42, 0x1p-42);
}


int main () { return 0; }