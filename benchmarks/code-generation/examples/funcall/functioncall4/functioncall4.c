// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real V1, real V2) =
\let DET = (V1 - V2) ;
((DET <= 0) ? (2) : (-2));
}
*/


/*@
axiomatic fp_function_f {
logic integer fp_f (double V1_double, double V2_double) =
\let DET_double = Dsub(V1_double, V2_double) ;
((DET_double <= (double) (0)) ? (2) : (-2));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real V1, real V2, double V1_double, double V2_double) =
((! (((V1 - V2) <= 0)) && ! ((Dsub(V1_double, V2_double) <= (double) (0)))) || (((V1 - V2) <= 0) && (Dsub(V1_double, V2_double) <= (double) (0))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(V1_double, V2_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real V1, real V2; (((\let DET_double = Dsub(V1_double, V2_double);
                                           \let DET = (V1 - V2);
                                           \abs(DET_double - DET) <= E_0_double && \let DET_double = Dsub(V1_double, V2_double);
                                                                                   \let DET = (V1 - V2);
                                                                                   \abs(DET_double - DET) <= E_1_double)
                                          ==> (f_stable_paths(V1, V2, V1_double, V2_double)))))) ;
*/
struct maybeInt f_int (double V1_double, double V2_double, double E_0_double, double E_1_double) {
  struct maybeInt res;
  double DET_double = (V1_double - V2_double);
  if (DET_double <= - (E_0_double))
  { res = some(2);
  } else { if (DET_double > E_1_double)
           { res = some(-2);
           } else { res = none();
           }
  }
  return res;
}


/*@
ensures (\forall real V1, real V2; (((((-60000 <= V1) && (V1 <= 60000)) && ((-60000 <= V2) && (V2 <= 60000))) && (\result.isValid && (\abs(V1_double - V1) <= ulp_dp(V1)/2 && \abs(V2_double - V2) <= ulp_dp(V2)/2))))
         ==> ((\abs((\result.value - f(V1, V2))) <= 0x0p+0))) ;
*/
struct maybeInt f_num (double V1_double, double V2_double) {
  return f_int (V1_double, V2_double, 0x1p-36, 0x1p-36);
}


/*@
axiomatic real_function_g {
logic integer g (real X, real Y) =
(X < 0) ? ((1 + f(X, Y))) : ((2 + f(Y, X)));
}
*/


/*@
axiomatic fp_function_g {
logic integer fp_g (double X_double, double Y_double) =
(X_double < (double) (0)) ? (Iadd(1, fp_f(X_double, Y_double))) : (Iadd(2, fp_f(Y_double, X_double)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real X, real Y, double X_double, double Y_double) =
(((((! (((X - Y) <= 0)) && (X < 0)) && (! ((Dsub(X_double, Y_double) <= (double) (0))) && (X_double < (double) (0)))) || ((! (((Y - X) <= 0)) && ! ((X < 0))) && (! ((Dsub(Y_double, X_double) <= (double) (0))) && ! ((X_double < (double) (0)))))) || ((((X - Y) <= 0) && (X < 0)) && ((Dsub(X_double, Y_double) <= (double) (0)) && (X_double < (double) (0))))) || ((((Y - X) <= 0) && ! ((X < 0))) && ((Dsub(Y_double, X_double) <= (double) (0)) && ! ((X_double < (double) (0))))));
}
*/


/*@
requires (((((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) && (0 <= E_3_double)) && (0 <= E_4_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_g(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; ((((((((X_double < (double) (0))
                                             ==> (\let DET_double = Dsub(X_double, Y_double);
                                                  \let DET = (X - Y);
                                                  \abs(Dsub(X_double, Y_double) - (X - Y)) <= E_0_double)) && ((X_double < (double) (0))
                                                                                                               ==> (\let DET_double = Dsub(X_double, Y_double);
                                                                                                                    \let DET = (X - Y);
                                                                                                                    \abs(Dsub(X_double, Y_double) - (X - Y)) <= E_1_double))) && (! ((X_double < (double) (0)))
                                                                                                                                                                                  ==> (\let DET_double = Dsub(Y_double, X_double);
                                                                                                                                                                                       \let DET = (Y - X);
                                                                                                                                                                                       \abs(Dsub(Y_double, X_double) - (Y - X)) <= E_2_double))) && (! ((X_double < (double) (0)))
                                                                                                                                                                                                                                                     ==> (\let DET_double = Dsub(Y_double, X_double);
                                                                                                                                                                                                                                                          \let DET = (Y - X);
                                                                                                                                                                                                                                                          \abs(Dsub(Y_double, X_double) - (Y - X)) <= E_3_double))) && \abs(X_double - X) <= E_4_double)
                                        ==> (g_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt g_int (double X_double, double Y_double, double E_0_double, double E_1_double, double E_2_double, double E_3_double, double E_4_double) {
  struct maybeInt res;
  struct maybeInt aux_0 = f_int (X_double, Y_double, E_0_double, E_1_double);
  struct maybeInt aux_1 = f_int (Y_double, X_double, E_2_double, E_3_double);
  if ((aux_0.isValid) && (aux_1.isValid))
  { if (X_double < - (E_4_double))
    { struct maybeInt aux_2 = aux_0;
      if (aux_0.isValid)
      { res = some((1 + aux_0.value));
      } else { res = none();
      }
    } else { if (X_double >= E_4_double)
             { struct maybeInt aux_3 = aux_1;
               if (aux_1.isValid)
               { res = some((2 + aux_1.value));
               } else { res = none();
               }
             } else { res = none();
             }
    }
  } else { res = none();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-60000 <= Y) && (Y <= 60000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - g(X, Y))) <= 0x0p+0))) ;
*/
struct maybeInt g_num (double X_double, double Y_double) {
  return g_int (X_double, Y_double, 0x1p-36, 0x1p-36, 0x1p-36, 0x1p-36, 0x1p-38);
}


int main () { return 0; }