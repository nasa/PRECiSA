// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real V1, real V2) =
\let DET = (V1 - V2) ;
((DET <= 0) ? (2) : (-2));
}
*/


/*@
axiomatic fp_function_f {
logic integer fp_f (double V1_double, double V2_double) =
\let DET_double = Dsub(V1_double, V2_double) ;
((DET_double <= (double) (0)) ? (2) : (-2));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real V1, real V2, double V1_double, double V2_double) =
((! (((V1 - V2) <= 0)) && ! ((Dsub(V1_double, V2_double) <= (double) (0)))) || (((V1 - V2) <= 0) && (Dsub(V1_double, V2_double) <= (double) (0))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(V1_double, V2_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real V1, real V2; (((\let DET_double = Dsub(V1_double, V2_double);
                                           \let DET = (V1 - V2);
                                           \abs(DET_double - DET) <= E_0_double && \let DET_double = Dsub(V1_double, V2_double);
                                                                                   \let DET = (V1 - V2);
                                                                                   \abs(DET_double - DET) <= E_1_double)
                                          ==> (f_stable_paths(V1, V2, V1_double, V2_double)))))) ;
*/
struct maybeInt f_int (double V1_double, double V2_double, double E_0_double, double E_1_double) {
  struct maybeInt res;
  double DET_double = (V1_double - V2_double);
  if (DET_double <= - (E_0_double))
  { res = some(2);
  } else { if (DET_double > E_1_double)
           { res = some(-2);
           } else { res = none();
           }
  }
  return res;
}


/*@
ensures (\forall real V1, real V2; (((((-60000 <= V1) && (V1 <= 60000)) && ((-60000 <= V2) && (V2 <= 60000))) && (\result.isValid && (\abs(V1_double - V1) <= ulp_dp(V1)/2 && \abs(V2_double - V2) <= ulp_dp(V2)/2))))
         ==> ((\abs((\result.value - f(V1, V2))) <= 0x0p+0))) ;
*/
struct maybeInt f_num (double V1_double, double V2_double) {
  return f_int (V1_double, V2_double, 0x1p-36, 0x1p-36);
}


/*@
axiomatic real_function_g {
logic integer g (real X, real Y) =
\let A = f(X, Y) ;
\let B = f(Y, X) ;
\let C = (X * Y) ;
((C < 0) ? ((1 + A)) : ((2 + B)));
}
*/


/*@
axiomatic fp_function_g {
logic integer fp_g (double X_double, double Y_double) =
\let A = fp_f(X_double, Y_double) ;
\let B = fp_f(Y_double, X_double) ;
\let C_double = Dmul(X_double, Y_double) ;
((C_double < (double) (0)) ? (Iadd(1, A)) : (Iadd(2, B)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real X, real Y, double X_double, double Y_double) =
((((((((((((((((((((((((! (((X * Y) < 0)) && ! ((Dmul(X_double, Y_double) < (double) (0)))) || (! (((X - Y) <= 0)) && ! ((Dsub(X_double, Y_double) <= (double) (0))))) || (! (((Y - X) <= 0)) && ! ((Dsub(Y_double, X_double) <= (double) (0))))) || (((X * Y) < 0) && (Dmul(X_double, Y_double) < (double) (0)))) || (((X - Y) <= 0) && (Dsub(X_double, Y_double) <= (double) (0)))) || (((Y - X) <= 0) && (Dsub(Y_double, X_double) <= (double) (0)))) || (! (((X * Y) < 0)) && ! ((Dmul(X_double, Y_double) < (double) (0))))) || (! (((X - Y) <= 0)) && ! ((Dsub(X_double, Y_double) <= (double) (0))))) || (! (((Y - X) <= 0)) && ! ((Dsub(Y_double, X_double) <= (double) (0))))) || (((X * Y) < 0) && (Dmul(X_double, Y_double) < (double) (0)))) || (((X - Y) <= 0) && (Dsub(X_double, Y_double) <= (double) (0)))) || (((Y - X) <= 0) && (Dsub(Y_double, X_double) <= (double) (0)))) || (! (((X * Y) < 0)) && ! ((Dmul(X_double, Y_double) < (double) (0))))) || (! (((X - Y) <= 0)) && ! ((Dsub(X_double, Y_double) <= (double) (0))))) || (! (((Y - X) <= 0)) && ! ((Dsub(Y_double, X_double) <= (double) (0))))) || (((X * Y) < 0) && (Dmul(X_double, Y_double) < (double) (0)))) || (((X - Y) <= 0) && (Dsub(X_double, Y_double) <= (double) (0)))) || (((Y - X) <= 0) && (Dsub(Y_double, X_double) <= (double) (0)))) || (! (((X * Y) < 0)) && ! ((Dmul(X_double, Y_double) < (double) (0))))) || (! (((X - Y) <= 0)) && ! ((Dsub(X_double, Y_double) <= (double) (0))))) || (! (((Y - X) <= 0)) && ! ((Dsub(Y_double, X_double) <= (double) (0))))) || (((X * Y) < 0) && (Dmul(X_double, Y_double) < (double) (0)))) || (((X - Y) <= 0) && (Dsub(X_double, Y_double) <= (double) (0)))) || (((Y - X) <= 0) && (Dsub(Y_double, X_double) <= (double) (0))));
}
*/


/*@
requires ((((((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) && (0 <= E_3_double)) && (0 <= E_4_double)) && (0 <= E_5_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_g(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; (((((((\let DET_double = Dsub(X_double, Y_double);
                                             \let DET = (X - Y);
                                             \abs(Dsub(X_double, Y_double) - (X - Y)) <= E_0_double && \let DET_double = Dsub(X_double, Y_double);
                                                                                                       \let DET = (X - Y);
                                                                                                       \abs(Dsub(X_double, Y_double) - (X - Y)) <= E_1_double) && \let DET_double = Dsub(Y_double, X_double);
                                                                                                                                                                  \let DET = (Y - X);
                                                                                                                                                                  \abs(Dsub(Y_double, X_double) - (Y - X)) <= E_2_double) && \let DET_double = Dsub(Y_double, X_double);
                                                                                                                                                                                                                             \let DET = (Y - X);
                                                                                                                                                                                                                             \abs(Dsub(Y_double, X_double) - (Y - X)) <= E_3_double) && \let C_double = Dmul(X_double, Y_double);
                                                                                                                                                                                                                                                                                        \let C = (X * Y);
                                                                                                                                                                                                                                                                                        \abs(C_double - C) <= E_4_double) && \let C_double = Dmul(X_double, Y_double);
                                                                                                                                                                                                                                                                                                                             \let C = (X * Y);
                                                                                                                                                                                                                                                                                                                             \abs(C_double - C) <= E_5_double)
                                        ==> (g_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt g_int (double X_double, double Y_double, double E_0_double, double E_1_double, double E_2_double, double E_3_double, double E_4_double, double E_5_double) {
  struct maybeInt res;
  struct maybeInt aux_0 = f_int (X_double, Y_double, E_0_double, E_1_double);
  if (aux_0.isValid)
  { int A = aux_0.value;
    struct maybeInt aux_1 = f_int (Y_double, X_double, E_2_double, E_3_double);
    if (aux_1.isValid)
    { int B = aux_1.value;
      double C_double = (X_double * Y_double);
      if (C_double < - (E_4_double))
      { res = some((1 + A));
      } else { if (C_double >= E_5_double)
               { res = some((2 + B));
               } else { res = none();
               }
      }
    } else { res = none();
    }
  } else { res = none();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-60000 <= Y) && (Y <= 60000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - g(X, Y))) <= 0x0p+0))) ;
*/
struct maybeInt g_num (double X_double, double Y_double) {
  return g_int (X_double, Y_double, 0x1p-36, 0x1p-36, 0x1p-36, 0x1p-36, 0x1.6a60000000001p-21, 0x1.6a60000000001p-21);
}


int main () { return 0; }