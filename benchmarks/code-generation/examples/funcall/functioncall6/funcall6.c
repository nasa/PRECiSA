// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_pred_f {
logic boolean f (real sx, real vx) =
\let t = (sx + vx) ;
((t <= 0));
}
*/


/*@
axiomatic fp_pred_f {
logic boolean fp_f (double sx_double, double vx_double) =
\let t_double = Dadd(sx_double, vx_double) ;
((t_double <= (double) (0)));
}
*/


/*@ axiomatic f_tauplus_trans {
predicate f_tauplus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
(\true && \true);
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; (((\let t_double = Dadd(sx_double, vx_double);
                                     \let t = (sx + vx);
                                     \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                         \let t = (sx + vx);
                                                                         \abs(t_double - t) <= E_1_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((f(sx, vx) && fp_f(sx_double, vx_double))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((\let t_double = Dadd(sx_double, vx_double);
                                           \let t = (sx + vx);
                                           \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                               \let t = (sx + vx);
                                                                               \abs(t_double - t) <= E_1_double)
                                          ==> (f_tauplus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool f_tauplus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  double t_double = (sx_double + vx_double);
  res = someBool(t_double <= - (E_0_double));
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (f(sx, vx))))) ;
*/
struct maybeBool f_tauplus_num (double sx_double, double vx_double) {
  return f_tauplus_bool (sx_double, vx_double, 0x1p-42, 0x1p-42);
}




/*@ axiomatic f_tauminus_trans {
predicate f_tauminus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
(\true && \true);
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; (((\let t_double = Dadd(sx_double, vx_double);
                                     \let t = (sx + vx);
                                     \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                         \let t = (sx + vx);
                                                                         \abs(t_double - t) <= E_1_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((! (f(sx, vx)) && ! (fp_f(sx_double, vx_double)))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((\let t_double = Dadd(sx_double, vx_double);
                                           \let t = (sx + vx);
                                           \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                               \let t = (sx + vx);
                                                                               \abs(t_double - t) <= E_1_double)
                                          ==> (f_tauminus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool f_tauminus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  double t_double = (sx_double + vx_double);
  res = someBool(t_double > E_1_double);
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (! (f(sx, vx)))))) ;
*/
struct maybeBool f_tauminus_num (double sx_double, double vx_double) {
  return f_tauminus_bool (sx_double, vx_double, 0x1p-42, 0x1p-42);
}


/*@
axiomatic real_pred_g {
logic boolean g (real sx, real vx) =
f(sx, vx);
}
*/


/*@
axiomatic fp_pred_g {
logic boolean fp_g (double sx_double, double vx_double) =
fp_f(sx_double, vx_double);
}
*/


/*@ axiomatic g_tauplus_trans {
predicate g_tauplus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
(\true && \true);
}
*/


/*@
requires ((((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) && (0 <= E_3_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; (((((\let t_double = Dadd(sx_double, vx_double);
                                       \let t = (sx + vx);
                                       \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                           \let t = (sx + vx);
                                                                           \abs(t_double - t) <= E_1_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                \let t = (sx + vx);
                                                                                                                \abs(t_double - t) <= E_2_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                                                     \let t = (sx + vx);
                                                                                                                                                     \abs(t_double - t) <= E_3_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((g(sx, vx) && fp_g(sx_double, vx_double))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((((\let t_double = Dadd(sx_double, vx_double);
                                             \let t = (sx + vx);
                                             \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                                 \let t = (sx + vx);
                                                                                 \abs(t_double - t) <= E_1_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                      \let t = (sx + vx);
                                                                                                                      \abs(t_double - t) <= E_2_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                                                           \let t = (sx + vx);
                                                                                                                                                           \abs(t_double - t) <= E_3_double)
                                          ==> (g_tauplus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool g_tauplus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double, double E_2_double, double E_3_double) {
  struct maybeBool res;
  struct maybeBool aux_0 = f_tauplus_bool(sx_double, vx_double, E_0_double, E_1_double);
  if (aux_0.isValid)
  { res = someBool(aux_0.value);
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (g(sx, vx))))) ;
*/
struct maybeBool g_tauplus_num (double sx_double, double vx_double) {
  return g_tauplus_bool (sx_double, vx_double, 0x1p-42, 0x1p-42, 0x1p-42, 0x1p-42);
}




/*@ axiomatic g_tauminus_trans {
predicate g_tauminus_stable_paths (real sx, real vx, double sx_double, double vx_double) =
(\true && \true);
}
*/


/*@
requires ((((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) && (0 <= E_3_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real sx, real vx; (((((\let t_double = Dadd(sx_double, vx_double);
                                       \let t = (sx + vx);
                                       \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                           \let t = (sx + vx);
                                                                           \abs(t_double - t) <= E_1_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                \let t = (sx + vx);
                                                                                                                \abs(t_double - t) <= E_2_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                                                     \let t = (sx + vx);
                                                                                                                                                     \abs(t_double - t) <= E_3_double)
                                    ==> (((\result.value && \result.isValid)
                                          ==> ((! (g(sx, vx)) && ! (fp_g(sx_double, vx_double)))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real sx, real vx; (((((\let t_double = Dadd(sx_double, vx_double);
                                             \let t = (sx + vx);
                                             \abs(t_double - t) <= E_0_double && \let t_double = Dadd(sx_double, vx_double);
                                                                                 \let t = (sx + vx);
                                                                                 \abs(t_double - t) <= E_1_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                      \let t = (sx + vx);
                                                                                                                      \abs(t_double - t) <= E_2_double) && \let t_double = Dadd(sx_double, vx_double);
                                                                                                                                                           \let t = (sx + vx);
                                                                                                                                                           \abs(t_double - t) <= E_3_double)
                                          ==> (g_tauminus_stable_paths(sx, vx, sx_double, vx_double)))))) ;
*/
struct maybeBool g_tauminus_bool (double sx_double, double vx_double, double E_0_double, double E_1_double, double E_2_double, double E_3_double) {
  struct maybeBool res;
  struct maybeBool aux_0 = f_tauminus_bool(sx_double, vx_double, E_2_double, E_3_double);
  if (aux_0.isValid)
  { res = someBool(aux_0.value);
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real sx, real vx; (((((1 <= sx) && (sx <= 1000)) && ((1 <= vx) && (vx <= 1000))) && (\result.isValid && (\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2))))
         ==> ((\result.value
               ==> (! (g(sx, vx)))))) ;
*/
struct maybeBool g_tauminus_num (double sx_double, double vx_double) {
  return g_tauminus_bool (sx_double, vx_double, 0x1p-42, 0x1p-42, 0x1p-42, 0x1p-42);
}


int main () { return 0; }