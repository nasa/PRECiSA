// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real X) =
(0 < ((X * X) - 2)) ? ((X + X)) : ((X - X));
}
*/


/*@
axiomatic fp_function_f {
logic double fp_f (double X_double) =
((double) (0) < Dsub(Dmul(X_double, X_double), (double) (2))) ? (Dadd(X_double, X_double)) : (Dsub(X_double, X_double));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real X, double X_double) =
((! ((0 < ((X * X) - 2))) && ! (((double) (0) < Dsub(Dmul(X_double, X_double), (double) (2))))) || ((0 < ((X * X) - 2)) && ((double) (0) < Dsub(Dmul(X_double, X_double), (double) (2)))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(X_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X; ((\abs(Dsub(Dmul(X_double, X_double), (double) (2)) - ((X * X) - 2)) <= E_0_double
                                ==> (f_stable_paths(X, X_double)))))) ;
*/
struct maybeDouble f_double (double X_double, double E_0_double) {
  struct maybeDouble res;
  if (E_0_double < ((X_double * X_double) - (double)(2)))
  { res = someDouble((X_double + X_double));
  } else { if (- (E_0_double) >= ((X_double * X_double) - (double)(2)))
           { res = someDouble((X_double - X_double));
           } else { res = noneDouble();
           }
  }
  return res;
}


/*@
ensures (\forall real X; ((((0 <= X) && (X <= 100)) && (\result.isValid && \abs(X_double - X) <= ulp_dp(X)/2)))
         ==> ((\abs((\result.value - f(X))) <= 0x1p-45))) ;
*/
struct maybeDouble f_num (double X_double) {
  return f_double (X_double, 0x1.c800000000001p-39);
}


/*@
axiomatic real_function_g {
logic real g (real X) =
(0 < (X * X)) ? (-1) : (f((X * X)));
}
*/


/*@
axiomatic fp_function_g {
logic double fp_g (double X_double) =
((double) (0) < Dmul(X_double, X_double)) ? ((double) (-1)) : (fp_f(Dmul(X_double, X_double)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real X, double X_double) =
((((! ((0 < (((X * X) * (X * X)) - 2))) && ! ((0 < (X * X)))) && (! (((double) (0) < Dsub(Dmul(Dmul(X_double, X_double), Dmul(X_double, X_double)), (double) (2)))) && ! (((double) (0) < Dmul(X_double, X_double))))) || (((0 < (((X * X) * (X * X)) - 2)) && ! ((0 < (X * X)))) && (((double) (0) < Dsub(Dmul(Dmul(X_double, X_double), Dmul(X_double, X_double)), (double) (2))) && ! (((double) (0) < Dmul(X_double, X_double)))))) || ((0 < (X * X)) && ((double) (0) < Dmul(X_double, X_double))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_g(X_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X; ((((! (((double) (0) < Dmul(X_double, X_double)))
                                  ==> (\abs(Dsub(Dmul(Dmul(X_double, X_double), Dmul(X_double, X_double)), (double) (2)) - (((X * X) * (X * X)) - 2)) <= E_0_double)) && \abs(Dmul(X_double, X_double) - (X * X)) <= E_1_double)
                                ==> (g_stable_paths(X, X_double)))))) ;
*/
struct maybeDouble g_double (double X_double, double E_0_double, double E_1_double) {
  struct maybeDouble res;
  struct maybeDouble aux_0 = f_double ((X_double * X_double), E_0_double);
  if (aux_0.isValid)
  { if (E_1_double < (X_double * X_double))
    { res = someDouble((double)(-1));
    } else { if (- (E_1_double) >= (X_double * X_double))
             { res = someDouble(aux_0.value);
             } else { res = noneDouble();
             }
    }
  } else { res = noneDouble();
  }
  return res;
}


/*@
ensures (\forall real X; ((((0 <= X) && (X <= 100)) && (\result.isValid && \abs(X_double - X) <= ulp_dp(X)/2)))
         ==> ((\abs((\result.value - g(X))) <= 0x1.c800000000001p-38))) ;
*/
struct maybeDouble g_num (double X_double) {
  return g_double (X_double, 0x1.0832000000002p-24, 0x1.4800000000001p-39);
}


int main () { return 0; }