// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real X) =
(X > 0) ? (1) : (2);
}
*/


/*@
axiomatic fp_function_f {
logic integer fp_f (double double_X) =
(double_X > (double) (0)) ? (1) : (2);
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real X, double double_X) =
((! ((X > 0)) && ! ((double_X > (double) (0)))) || ((X > 0) && (double_X > (double) (0))));
}
*/


/*@
requires (0 <= double_E_0) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(double_X)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X; ((\abs(double_X - X) <= double_E_0
                                ==> (f_stable_paths(X, double_X)))))) ;
*/
struct maybeInt f_int (double double_X, double double_E_0) {
  struct maybeInt res;
  if (double_X > double_E_0)
  { res = some(1);
  } else { if (double_X <= - (double_E_0))
           { res = some(2);
           } else { res = none();
           }
  }
  return res;
}


/*@
ensures (\forall real X; ((((1 <= X) && (X <= 4)) && (\result.isValid && \abs(double_X - X) <= ulp_dp(X)/2)))
         ==> ((\abs((\result.value - f(X))) <= 0x0p+0))) ;
*/
struct maybeInt f_num (double double_X) {
  return f_int (double_X, 0x1p-51);
}


/*@
axiomatic real_function_for_forloop1 {
logic integer for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (for_forloop1((I + 1), (I < 2) ? ((Acc + f(1))) : ((Acc * f(2))), N));
}
*/
/*@
axiomatic real_function_forloop {
logic integer forloop (integer N) =
for_forloop1(0, 0, N);
}
*/
/*@
axiomatic fp_function_for_forloop1 {
logic integer fp_for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (fp_for_forloop1(Iadd(I, 1), ((double) (I) < (double) (2)) ? (Iadd(Acc, fp_f((double) 1))) : (Imul(Acc, fp_f((double) 2))), N));
}
*/


/*@
axiomatic fp_function_forloop {
logic integer fp_forloop (integer N) =
fp_for_forloop1(0, 0, N);
}
*/


/*@ axiomatic forloop_trans {
predicate forloop_stable_paths (integer N) =
\forall integer I; (((0 <= I <= 4)
                     ==> ((\true && \true))));
}
*/


/*@
requires ((0 <= double_E_0) && (0 <= double_E_1)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_forloop(N)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall integer I; ((0 <= I <= 4)) ==> (((double) (I) < (double) (2))
                 ==> (\abs(1 - 1) <= double_E_0)) && (! (((double) (I) < (double) (2)))
                                                      ==> (\abs(2 - 2) <= double_E_1))))
               ==> (forloop_stable_paths(N)) ;
*/
struct maybeInt forloop_int (int N, double double_E_0, double double_E_1) {
  struct maybeInt res;
  int I;
  int Acc = 0;
  res = some(Acc);
  /*@
  loop assigns I, Acc, res ;
  loop invariant (((I <= 0 <= 4) && (I > 0))
                  ==> ((\abs((Acc - for_forloop1((I - 1), Acc, N))) <= 0))) ;
  loop variant (4 - I) ;
  @*/
  for(I=0; I<=4; I++) {
  if (res.isValid)
  { struct maybeInt aux_0 = f_int (1, double_E_0);
    struct maybeInt aux_1 = f_int (2, double_E_1);
    if ((aux_0.isValid) && (aux_1.isValid))
    { if ((double)(I) < (double)(2))
      { struct maybeInt aux_2 = aux_0;
        if (aux_0.isValid)
        { res = some((Acc + aux_0.value));
        } else { res = none();
        }
      } else { struct maybeInt aux_3 = aux_1;
               if (aux_1.isValid)
               { res = some((Acc * aux_1.value));
               } else { res = none();
               }
      }
    } else { res = none();
    }
  } else { res = none();
  };
  }
  return res;
}


/*@
ensures (\forall integer N; (((\forall integer I; ((0 <= I <= 4))
                               ==> (((0 <= N) && (N <= 10)))) && (\result.isValid && \true)))
         ==> ((\abs((\result.value - forloop(N))) <= 0x0p+0))) ;
*/
struct maybeInt forloop_num (int N) {
  return forloop_int (N, 0x0p+0, 0x0p+0);
}


int main () { return 0; }
