// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real X) =
(X > 0) ? (1) : (2);
}
*/


/*@
axiomatic fp_function_f {
logic integer fp_f (double X_double) =
(X_double > (double) (0)) ? (1) : (2);
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real X, double X_double) =
((! ((X > 0)) && ! ((X_double > (double) (0)))) || ((X > 0) && (X_double > (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(X_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X; ((\abs(X_double - X) <= E_0_double
                                ==> (f_stable_paths(X, X_double)))))) ;
*/
struct maybeInt f_int (double X_double, double E_0_double) {
  struct maybeInt res;
  if (X_double > E_0_double)
  { res = some(1);
  } else { if (X_double <= - (E_0_double))
           { res = some(2);
           } else { res = none();
           }
  }
  return res;
}


/*@
ensures (\forall real X; ((((1 <= X) && (X <= 4)) && (\result.isValid && \abs(X_double - X) <= ulp_dp(X)/2)))
         ==> ((\abs((\result.value - f(X))) <= 0x0p+0))) ;
*/
struct maybeInt f_num (double X_double) {
  return f_int (X_double, 0x1p-51);
}


/*@
axiomatic real_function_for_forloop1 {
logic integer for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (for_forloop1((I + 1), (I < 2) ? ((Acc + f(1))) : ((Acc * f(2))), N));
}
*/
/*@
axiomatic real_function_forloop {
logic integer forloop (integer N) =
for_forloop1(0, 0, N);
}
*/
/*@
axiomatic fp_function_for_forloop1 {
logic integer fp_for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (fp_for_forloop1(Iadd(I, 1), (I < 2) ? (Iadd(Acc, fp_f((double) (1)))) : (Imul(Acc, fp_f((double) (2)))), N));
}
*/


/*@
axiomatic fp_function_forloop {
logic integer fp_forloop (integer N) =
fp_for_forloop1(0, 0, N);
}
*/


/*@ axiomatic forloop_trans {
predicate forloop_stable_paths (integer N) =
\forall integer I; (((0 <= I <= 4)
                     ==> ((\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_forloop(N)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall integer I; (((0 <= I <= 4)
                                   ==> (((((I < 2)
                                           ==> (\abs((double) (1) - 1) <= E_0_double)) && (! ((I < 2))
                                                                                           ==> (\abs((double) (2) - 2) <= E_1_double)))
                                         ==> (forloop_stable_paths(N)))))))) ;
*/
struct maybeInt forloop_int (int N, double E_0_double, double E_1_double) {
  struct maybeInt res;
  int I;
  int Acc = 0;
  res = some(Acc);
  /*@
  loop assigns I, Acc, res ;
  loop invariant (((I <= 0 <= 4) && (I > 0))
                  ==> ((\abs((Acc - for_forloop1((I - 1), Acc, N))) <= 0))) ;
  loop variant (4 - I) ;
  @*/
  for(I=0; I<=4; I++) {
  if (res.isValid)
  { struct maybeInt aux_0 = f_int ((double)(1), E_0_double);
    struct maybeInt aux_1 = f_int ((double)(2), E_1_double);
    if ((aux_0.isValid) && (aux_1.isValid))
    { if (I < 2)
      { struct maybeInt aux_2 = aux_0;
        if (aux_0.isValid)
        { res = some((Acc + aux_0.value));
        } else { res = none();
        }
      } else { struct maybeInt aux_3 = aux_1;
               if (aux_1.isValid)
               { res = some((Acc * aux_1.value));
               } else { res = none();
               }
      }
    } else { res = none();
    }
  } else { res = none();
  };
  }
  return res;
}


/*@
ensures (\forall integer N; (((\forall integer I; ((0 <= I <= 4))
                               ==> (((0 <= N) && (N <= 10)))) && (\result.isValid && \true)))
         ==> ((\abs((\result.value - forloop(N))) <= 0x0p+0))) ;
*/
struct maybeInt forloop_num (int N) {
  return forloop_int (N, 0x0p+0, 0x0p+0);
}


int main () { return 0; }