// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_for_forloop1 {
logic integer for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (for_forloop1((I + 1), (I + Acc), N));
}
*/
/*@
axiomatic real_function_forloop {
logic integer forloop (integer N) =
for_forloop1(0, 0, N);
}
*/
/*@
axiomatic fp_function_for_forloop1 {
logic integer fp_for_forloop1{L} (integer I, integer Acc, integer N) =
(I == 4) ? (Acc) : (fp_for_forloop1(Iadd(I, 1), Iadd(I, Acc), N));
}
*/


/*@
axiomatic fp_function_forloop {
logic integer fp_forloop (integer N) =
fp_for_forloop1(0, 0, N);
}
*/


/*@ axiomatic forloop_trans {
predicate forloop_stable_paths (integer N) =
\forall integer I; (((0 <= I <= 4)
                     ==> ((\true && \true))));
}
*/


/*@
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_forloop(N)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall integer I; (((0 <= I <= 4)
                                   ==> (forloop_stable_paths(N)))))) ;
*/
struct maybeInt forloop_int (int N) {
  struct maybeInt res;
  int I;
  int Acc = 0;
  res = some(Acc);
  /*@
  loop assigns I, Acc, res ;
  loop invariant (((I <= 0 <= 4) && (I > 0))
                  ==> ((\abs((Acc - for_forloop1((I - 1), Acc, N))) <= 0))) ;
  loop variant (4 - I) ;
  @*/
  for(I=0; I<=4; I++) {
  if (res.isValid)
  { res = some((I + Acc));
  } else { res = none();
  };
  }
  return res;
}


/*@
ensures (\forall integer N; (((\forall integer I; ((0 <= I <= 4))
                               ==> (((0 <= N) && (N <= 10)))) && (\result.isValid && \true)))
         ==> ((\abs((\result.value - forloop(N))) <= 0x0p+0))) ;
*/
struct maybeInt forloop_num (int N) {
  return forloop_int (N);
}


int main () { return 0; }