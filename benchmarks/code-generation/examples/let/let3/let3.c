// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real X) =
(X * 2);
}
*/


/*@
axiomatic fp_function_f {
logic double fp_f (double X_double) =
Dmul(X_double, (double) (2));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real X, double X_double) =
(\true && \true);
}
*/


/*@
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_f(X_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X; (f_stable_paths(X, X_double)))) ;
*/
struct maybeDouble f_double (double X_double) {
  struct maybeDouble res;
  res = someDouble((X_double * (double)(2)));
  return res;
}


/*@
ensures (\forall real X; ((((0 <= X) && (X <= 10)) && (\result.isValid && \abs(X_double - X) <= ulp_dp(X)/2)))
         ==> ((\abs((\result.value - f(X))) <= 0x1p-48))) ;
*/
struct maybeDouble f_num (double X_double) {
  return f_double (X_double);
}


/*@
axiomatic real_function_g {
logic real g (real X, real Y) =
\let A = (X + Y) ;
\let B = f(A) ;
((B < 0) ? ((1 + A)) : ((2 + B)));
}
*/


/*@
axiomatic fp_function_g {
logic double fp_g (double X_double, double Y_double) =
\let A_double = Dadd(X_double, Y_double) ;
\let B_double = fp_f(A_double) ;
((B_double < (double) (0)) ? (Dadd((double) (1), A_double)) : (Dadd((double) (2), B_double)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real X, real Y, double X_double, double Y_double) =
((! ((f((X + Y)) < 0)) && ! ((fp_f(Dadd(X_double, Y_double)) < (double) (0)))) || ((f((X + Y)) < 0) && (fp_f(Dadd(X_double, Y_double)) < (double) (0))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_g(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; (((\let A_double = Dadd(X_double, Y_double);
                                         \let A = (X + Y);
                                         \let B_double = fp_f(A_double);
                                         \let B = f(A);
                                         \abs(B_double - B) <= E_0_double && \let A_double = Dadd(X_double, Y_double);
                                                                             \let A = (X + Y);
                                                                             \let B_double = fp_f(A_double);
                                                                             \let B = f(A);
                                                                             \abs(B_double - B) <= E_1_double)
                                        ==> (g_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeDouble g_double (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeDouble res;
  double A_double = (X_double + Y_double);
  struct maybeDouble aux_0 = f_double (A_double);
  if (aux_0.isValid)
  { double B_double = aux_0.value;
    if (B_double < - (E_0_double))
    { res = someDouble(((double)(1) + A_double));
    } else { if (B_double >= E_1_double)
             { res = someDouble(((double)(2) + B_double));
             } else { res = noneDouble();
             }
    }
  } else { res = noneDouble();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((0 <= X) && (X <= 60)) && ((0 <= Y) && (Y <= 60))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - g(X, Y))) <= 0x1p-44))) ;
*/
struct maybeDouble g_num (double X_double, double Y_double) {
  return g_double (X_double, Y_double, 0x1.8p-45, 0x1.8p-45);
}


int main () { return 0; }