// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_mul {
logic real mul (real X, real Y) =
(X * Y);
}
*/


/*@
axiomatic fp_function_mul {
logic double fp_mul (double X_double, double Y_double) =
Dmul(X_double, Y_double);
}
*/


/*@ axiomatic mul_trans {
predicate mul_stable_paths (real X, real Y, double X_double, double Y_double) =
(\true && \true);
}
*/


/*@
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_mul(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; (mul_stable_paths(X, Y, X_double, Y_double)))) ;
*/
struct maybeDouble mul_double (double X_double, double Y_double) {
  struct maybeDouble res;
  res = someDouble((X_double * Y_double));
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - mul(X, Y))) <= 0x1.4350000000001p-23))) ;
*/
struct maybeDouble mul_num (double X_double, double Y_double) {
  return mul_double (X_double, Y_double);
}


/*@
axiomatic real_pred_positive {
logic boolean positive (real X, real Y) =
(mul(X, Y) > 0);
}
*/


/*@
axiomatic fp_pred_positive {
logic boolean fp_positive (double X_double, double Y_double) =
(fp_mul(X_double, Y_double) > (double) (0));
}
*/


/*@ axiomatic positive_tauplus_trans {
predicate positive_tauplus_stable_paths (real X, real Y, double X_double, double Y_double) =
(\true && \true);
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((\abs(fp_mul(X_double, Y_double) - mul(X, Y)) <= E_0_double
                                  ==> (((\result.value && \result.isValid)
                                        ==> ((positive(X, Y) && fp_positive(X_double, Y_double))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; ((\abs(fp_mul(X_double, Y_double) - mul(X, Y)) <= E_0_double
                                        ==> (positive_tauplus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool positive_tauplus_bool (double X_double, double Y_double, double E_0_double) {
  struct maybeBool res;
  struct maybeDouble aux_0 = mul_double (X_double, Y_double);
  if (aux_0.isValid)
  { res = someBool(aux_0.value > E_0_double);
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\result.value
               ==> (positive(X, Y))))) ;
*/
struct maybeBool positive_tauplus_num (double X_double, double Y_double) {
  return positive_tauplus_bool (X_double, Y_double, 0x1.4350000000001p-23);
}




/*@ axiomatic positive_tauminus_trans {
predicate positive_tauminus_stable_paths (real X, real Y, double X_double, double Y_double) =
(\true && \true);
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((\abs(fp_mul(X_double, Y_double) - mul(X, Y)) <= E_0_double
                                  ==> (((\result.value && \result.isValid)
                                        ==> ((! (positive(X, Y)) && ! (fp_positive(X_double, Y_double)))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; ((\abs(fp_mul(X_double, Y_double) - mul(X, Y)) <= E_0_double
                                        ==> (positive_tauminus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool positive_tauminus_bool (double X_double, double Y_double, double E_0_double) {
  struct maybeBool res;
  struct maybeDouble aux_0 = mul_double (X_double, Y_double);
  if (aux_0.isValid)
  { res = someBool(aux_0.value <= - (E_0_double));
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\result.value
               ==> (! (positive(X, Y)))))) ;
*/
struct maybeBool positive_tauminus_num (double X_double, double Y_double) {
  return positive_tauminus_bool (X_double, Y_double, 0x1.4350000000001p-23);
}


/*@
axiomatic real_function_test {
logic integer test (real X, real Y) =
positive(X, Y) ? (1) : (2);
}
*/


/*@
axiomatic fp_function_test {
logic integer fp_test (double X_double, double Y_double) =
fp_positive(X_double, Y_double) ? (1) : (2);
}
*/


/*@ axiomatic test_trans {
predicate test_stable_paths (real X, real Y, double X_double, double Y_double) =
((! (positive(X, Y)) && ! (fp_positive(X_double, Y_double))) || (positive(X, Y) && fp_positive(X_double, Y_double)));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_test(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; ((\abs(fp_mul(X_double, Y_double) - mul(X, Y)) <= E_0_double
                                        ==> (test_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt test_int (double X_double, double Y_double, double E_0_double) {
  struct maybeInt res;
  struct maybeBool aux_0 = positive_tauplus_bool(X_double, Y_double, E_0_double);
  struct maybeBool aux_1 = positive_tauminus_bool(X_double, Y_double, E_0_double);
  if ((aux_0.isValid) && (aux_1.isValid))
  { if (aux_0.value)
    { res = some(1);
    } else { if (aux_1.value)
             { res = some(2);
             } else { res = none();
             }
    }
  } else { res = none();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - test(X, Y))) <= 0x0p+0))) ;
*/
struct maybeInt test_num (double X_double, double Y_double) {
  return test_int (X_double, Y_double, 0x1.4350000000001p-23);
}


int main () { return 0; }