// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_quadrant {
logic integer quadrant (real X, real Y) =
(((0 <= X) && (0 <= Y)))
? 1 :
(((X <= 0) && (0 <= Y)))
? 2 :
((X <= 0))
? 3 :
4;
}
*/


/*@
axiomatic fp_function_quadrant {
logic integer fp_quadrant (double X_double, double Y_double) =
((((double) (0) <= X_double) && ((double) (0) <= Y_double)))
? 1 :
(((X_double <= (double) (0)) && ((double) (0) <= Y_double)))
? 2 :
((X_double <= (double) (0)))
? 3 :
4;
}
*/


/*@ axiomatic quadrant_trans {
predicate quadrant_stable_paths (real X, real Y, double X_double, double Y_double) =
(((((((X <= 0) && (0 <= Y)) && ! (((0 <= X) && (0 <= Y)))) && (((X_double <= (double) (0)) && ((double) (0) <= Y_double)) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))) || ((! ((X <= 0)) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && (! ((X_double <= (double) (0))) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))))) || (((0 <= X) && (0 <= Y)) && (((double) (0) <= X_double) && ((double) (0) <= Y_double)))) || (((X <= 0) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && ((X_double <= (double) (0)) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double)))))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures (\result.isValid
         ==> ((\result.value == fp_quadrant(X_double, Y_double)))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                        ==> (quadrant_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt quadrant_int (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeInt res;
  if ((E_0_double <= X_double) && (E_1_double <= Y_double))
  { res = some(1);;
  }
  else if (((X_double <= - (E_0_double)) && (E_1_double <= Y_double)) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(2);; }
  else if (((X_double <= - (E_0_double)) && ((X_double > E_0_double) || (- (E_1_double) > Y_double))) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(3);; }
  else if (((X_double > E_0_double) && ((X_double > E_0_double) || (- (E_1_double) > Y_double))) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(4);; }
  else { res = none();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> ((\abs((\result.value - quadrant(X, Y))) <= 0x0p+0))) ;
*/
struct maybeInt quadrant_num (double X_double, double Y_double) {
  return quadrant_int (X_double, Y_double, 0x1p-38, 0x1p-40);
}


/*@
axiomatic real_pred_first_quadrant {
logic boolean first_quadrant (real X, real Y) =
((quadrant(X, Y) - 1) == 0);
}
*/


/*@
axiomatic fp_pred_first_quadrant {
logic boolean fp_first_quadrant (double X_double, double Y_double) =
(Isub(fp_quadrant(X_double, Y_double), 1) == 0);
}
*/


/*@ axiomatic first_quadrant_trans {
predicate first_quadrant_stable_paths (real X, real Y, double X_double, double Y_double) =
(\true && \true);
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                  ==> ((\result.isValid
                                        ==> (((\result.value
                                               ==> ((first_quadrant(X, Y) && fp_first_quadrant(X_double, Y_double)))) && (! (\result.value)
                                                                                                                          ==> ((! (first_quadrant(X, Y)) && ! (fp_first_quadrant(X_double, Y_double))))))))))) ;

behavior stable_paths:
ensures (\result.isValid
         ==> (\forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                        ==> (first_quadrant_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool first_quadrant_bool (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeInt aux_0 = quadrant_int (X_double, Y_double, E_0_double, E_1_double);
  if (aux_0.isValid)
  { res = someBool((aux_0.value - 1) == 0);
  } else { res = noneBool();
  }
  return res;
}


/*@
ensures (\forall real X, real Y; (((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && (\result.isValid && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2))))
         ==> (\result.value
              <==> (first_quadrant(X, Y)))) ;
*/
struct maybeBool first_quadrant_num (double X_double, double Y_double) {
  return first_quadrant_bool (X_double, Y_double, 0x1p-38, 0x1p-40);
}


int main () { return 0; }