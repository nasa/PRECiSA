-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParDecisionPaths where
import AbsDecisionPaths
import LexDecisionPaths
import ErrM

}

%name pTargetDPs TargetDPs
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  ':' { PT _ (TS _ 4) }
  'All' { PT _ (TS _ 5) }
  'None' { PT _ (TS _ 6) }
  '[' { PT _ (TS _ 7) }
  ']' { PT _ (TS _ 8) }
  L_integ  { PT _ (TI $$) }
  L_Id { PT _ (T_Id $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Id :: { Id}
Id  : L_Id { Id ($1)}

Decision :: { Integer }
Decision : Integer { $1 }

ListDecision :: { [Integer] }
ListDecision : Decision { (:[]) $1 }
             | Decision ',' ListDecision { $3 ++ ($1:[]) }


DecisionPath :: { LDecisionPath }
DecisionPath : '[' ListDecision ']' { LDP $2 }


ListDecisionPath :: { [LDecisionPath] }
ListDecisionPath : {- empty -} { [] }
                 | DecisionPath { (:[]) $1 }
                 | DecisionPath ',' ListDecisionPath { (:) $1 $3 }

DecisionPaths :: { [LDecisionPath] }
DecisionPaths : ListDecisionPath { $1 }
              | 'All' { [LDP []] }
              | 'None' { [] }


ListId :: { [Id] }
ListId : Id { (:[]) $1 } | Id ',' ListId { (:) $1 $3 }

DecPathBind :: { (String, [LDecisionPath]) }
DecPathBind : Id '(' ListId ')' ':' DecisionPaths { buildDecisionPaths $1 $6 }
            | Id ':' DecisionPaths { buildDecisionPaths $1 $3 }

ListDecPathBind :: { [(String, [LDecisionPath])] }
ListDecPathBind : DecPathBind { (:[]) $1 }
                | DecPathBind ListDecPathBind { (:) $1 $2 }

TargetDPs :: { TargetDPs }
TargetDPs : ListDecPathBind { $1 }

{
buildDecisionPaths  :: Id -> [LDecisionPath] -> (String, [LDecisionPath])
buildDecisionPaths (Id fun) dps = (fun, dps)

rawparserTargetDPs :: String -> Err TargetDPs
rawparserTargetDPs = pTargetDPs . tokens

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

