-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParFPCore
  ( happyError
  , myLexer
  , pFPCore
  , pProperty
  , pListProperty
  , pArgument
  , pListArgument
  , pDimension
  , pListDimension
  , pExpr
  , pListExpr
  , pNumber
  , pData
  , pListData
  , pListSymEx
  , pSymEx
  , pListSymExEx
  , pSymExEx
  , pOperation
  , pConstant
  ) where

import Prelude

import qualified FPCore.Abs
import FPCore.Lex

}

%name pFPCore FPCore
%name pProperty Property
%name pListProperty ListProperty
%name pArgument Argument
%name pListArgument ListArgument
%name pDimension Dimension
%name pListDimension ListDimension
%name pExpr Expr
%name pListExpr ListExpr
%name pNumber Number
%name pData Data
%name pListData ListData
%name pListSymEx ListSymEx
%name pSymEx SymEx
%name pListSymExEx ListSymExEx
%name pSymExEx SymExEx
%name pOperation Operation
%name pConstant Constant
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)        }
  '!='         { PT _ (TS _ 2)        }
  '('          { PT _ (TS _ 3)        }
  ')'          { PT _ (TS _ 4)        }
  '*'          { PT _ (TS _ 5)        }
  '+'          { PT _ (TS _ 6)        }
  '-'          { PT _ (TS _ 7)        }
  '/'          { PT _ (TS _ 8)        }
  ':'          { PT _ (TS _ 9)        }
  '<'          { PT _ (TS _ 10)       }
  '<='         { PT _ (TS _ 11)       }
  '=='         { PT _ (TS _ 12)       }
  '>'          { PT _ (TS _ 13)       }
  '>='         { PT _ (TS _ 14)       }
  'E'          { PT _ (TS _ 15)       }
  'FALSE'      { PT _ (TS _ 16)       }
  'FPCore'     { PT _ (TS _ 17)       }
  'INFINITY'   { PT _ (TS _ 18)       }
  'LN10'       { PT _ (TS _ 19)       }
  'LN2'        { PT _ (TS _ 20)       }
  'LOG10E'     { PT _ (TS _ 21)       }
  'LOG2E'      { PT _ (TS _ 22)       }
  'M_1_PI'     { PT _ (TS _ 23)       }
  'M_2_PI'     { PT _ (TS _ 24)       }
  'M_2_SQRTPI' { PT _ (TS _ 25)       }
  'NAN'        { PT _ (TS _ 26)       }
  'PI'         { PT _ (TS _ 27)       }
  'PI_2'       { PT _ (TS _ 28)       }
  'PI_4'       { PT _ (TS _ 29)       }
  'SQRT1_2'    { PT _ (TS _ 30)       }
  'SQRT2'      { PT _ (TS _ 31)       }
  'TRUE'       { PT _ (TS _ 32)       }
  '['          { PT _ (TS _ 33)       }
  ']'          { PT _ (TS _ 34)       }
  'acos'       { PT _ (TS _ 35)       }
  'acosh'      { PT _ (TS _ 36)       }
  'and'        { PT _ (TS _ 37)       }
  'array'      { PT _ (TS _ 38)       }
  'asin'       { PT _ (TS _ 39)       }
  'asinh'      { PT _ (TS _ 40)       }
  'atan'       { PT _ (TS _ 41)       }
  'atan2'      { PT _ (TS _ 42)       }
  'atanh'      { PT _ (TS _ 43)       }
  'cast'       { PT _ (TS _ 44)       }
  'cbrt'       { PT _ (TS _ 45)       }
  'ceil'       { PT _ (TS _ 46)       }
  'copysign'   { PT _ (TS _ 47)       }
  'cos'        { PT _ (TS _ 48)       }
  'cosh'       { PT _ (TS _ 49)       }
  'digits'     { PT _ (TS _ 50)       }
  'dim'        { PT _ (TS _ 51)       }
  'erf'        { PT _ (TS _ 52)       }
  'erfc'       { PT _ (TS _ 53)       }
  'exp'        { PT _ (TS _ 54)       }
  'exp2'       { PT _ (TS _ 55)       }
  'expm1'      { PT _ (TS _ 56)       }
  'fabs'       { PT _ (TS _ 57)       }
  'fdim'       { PT _ (TS _ 58)       }
  'floor'      { PT _ (TS _ 59)       }
  'fma'        { PT _ (TS _ 60)       }
  'fmax'       { PT _ (TS _ 61)       }
  'fmin'       { PT _ (TS _ 62)       }
  'fmod'       { PT _ (TS _ 63)       }
  'for'        { PT _ (TS _ 64)       }
  'for*'       { PT _ (TS _ 65)       }
  'hypot'      { PT _ (TS _ 66)       }
  'if'         { PT _ (TS _ 67)       }
  'isfinite'   { PT _ (TS _ 68)       }
  'isinf'      { PT _ (TS _ 69)       }
  'isnan'      { PT _ (TS _ 70)       }
  'isnormal'   { PT _ (TS _ 71)       }
  'let'        { PT _ (TS _ 72)       }
  'let*'       { PT _ (TS _ 73)       }
  'lgamma'     { PT _ (TS _ 74)       }
  'log'        { PT _ (TS _ 75)       }
  'log10'      { PT _ (TS _ 76)       }
  'log1p'      { PT _ (TS _ 77)       }
  'log2'       { PT _ (TS _ 78)       }
  'nearbyint'  { PT _ (TS _ 79)       }
  'not'        { PT _ (TS _ 80)       }
  'or'         { PT _ (TS _ 81)       }
  'pow'        { PT _ (TS _ 82)       }
  'ref'        { PT _ (TS _ 83)       }
  'remainder'  { PT _ (TS _ 84)       }
  'round'      { PT _ (TS _ 85)       }
  'signbit'    { PT _ (TS _ 86)       }
  'sin'        { PT _ (TS _ 87)       }
  'sinh'       { PT _ (TS _ 88)       }
  'size'       { PT _ (TS _ 89)       }
  'sqrt'       { PT _ (TS _ 90)       }
  'tan'        { PT _ (TS _ 91)       }
  'tanh'       { PT _ (TS _ 92)       }
  'tensor'     { PT _ (TS _ 93)       }
  'tensor*'    { PT _ (TS _ 94)       }
  'tgamma'     { PT _ (TS _ 95)       }
  'trunc'      { PT _ (TS _ 96)       }
  'while'      { PT _ (TS _ 97)       }
  'while*'     { PT _ (TS _ 98)       }
  L_quoted     { PT _ (TL $$)         }
  L_Rational   { PT _ (T_Rational $$) }
  L_DecNum     { PT _ (T_DecNum $$)   }
  L_HexNum     { PT _ (T_HexNum $$)   }
  L_Symbol     { PT _ (T_Symbol $$)   }

%%

String  :: { String }
String   : L_quoted { $1 }

Rational :: { FPCore.Abs.Rational }
Rational  : L_Rational { FPCore.Abs.Rational $1 }

DecNum :: { FPCore.Abs.DecNum }
DecNum  : L_DecNum { FPCore.Abs.DecNum $1 }

HexNum :: { FPCore.Abs.HexNum }
HexNum  : L_HexNum { FPCore.Abs.HexNum $1 }

Symbol :: { FPCore.Abs.Symbol }
Symbol  : L_Symbol { FPCore.Abs.Symbol $1 }

FPCore :: { FPCore.Abs.FPCore }
FPCore
  : '(' 'FPCore' Symbol '(' ListArgument ')' ListProperty Expr ')' { FPCore.Abs.FProgram $3 $5 $7 $8 }
  | '(' 'FPCore' '(' ListArgument ')' ListProperty Expr ')' { FPCore.Abs.FProgramSymbless $4 $6 $7 }

Property :: { FPCore.Abs.Property }
Property : ':' Symbol Data { FPCore.Abs.Prop $2 $3 }

ListProperty :: { [FPCore.Abs.Property] }
ListProperty
  : {- empty -} { [] } | Property ListProperty { (:) $1 $2 }

Argument :: { FPCore.Abs.Argument }
Argument
  : Symbol { FPCore.Abs.ASym $1 }
  | '(' Symbol ListDimension ')' { FPCore.Abs.ASymDim $2 $3 }
  | '(' '!' ListProperty Symbol ListDimension ')' { FPCore.Abs.AProp $3 $4 $5 }

ListArgument :: { [FPCore.Abs.Argument] }
ListArgument
  : {- empty -} { [] } | Argument ListArgument { (:) $1 $2 }

Dimension :: { FPCore.Abs.Dimension }
Dimension
  : Symbol { FPCore.Abs.DimSym $1 } | Number { FPCore.Abs.DimNum $1 }

ListDimension :: { [FPCore.Abs.Dimension] }
ListDimension
  : {- empty -} { [] } | Dimension ListDimension { (:) $1 $2 }

Expr :: { FPCore.Abs.Expr }
Expr
  : Number { FPCore.Abs.ExNum $1 }
  | Constant { FPCore.Abs.ExConst $1 }
  | Symbol { FPCore.Abs.ExSym $1 }
  | '(' Operation Expr ListExpr ')' { FPCore.Abs.ExOp $2 $3 $4 }
  | '(' 'if' Expr Expr Expr ')' { FPCore.Abs.ExIf $3 $4 $5 }
  | '(' 'let' '(' ListSymEx ')' Expr ')' { FPCore.Abs.ExLet $4 $6 }
  | '(' 'let*' '(' ListSymEx ')' Expr ')' { FPCore.Abs.ExLetStar $4 $6 }
  | '(' 'while' Expr '(' ListSymExEx ')' Expr ')' { FPCore.Abs.ExWhile $3 $5 $7 }
  | '(' 'while*' Expr '(' ListSymExEx ')' Expr ')' { FPCore.Abs.ExWhileStar $3 $5 $7 }
  | '(' 'for' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { FPCore.Abs.ExFor $4 $7 $9 }
  | '(' 'for*' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { FPCore.Abs.ExForStar $4 $7 $9 }
  | '(' 'tensor' '(' ListSymEx ')' Expr ')' { FPCore.Abs.ExTensor $4 $6 }
  | '(' 'tensor*' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { FPCore.Abs.ExTensorStar $4 $7 $9 }
  | '(' 'cast' Expr ')' { FPCore.Abs.ExCast $3 }
  | '(' 'array' ListExpr ')' { FPCore.Abs.ExArray $3 }
  | '(' '!' ListProperty Expr ')' { FPCore.Abs.ExProp $3 $4 }

ListExpr :: { [FPCore.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Number :: { FPCore.Abs.Number }
Number
  : Rational { FPCore.Abs.NRat $1 }
  | DecNum { FPCore.Abs.NDecNum $1 }
  | HexNum { FPCore.Abs.NHexNum $1 }
  | '(' 'digits' DecNum DecNum DecNum ')' { FPCore.Abs.NDigits $3 $4 $5 }

Data :: { FPCore.Abs.Data }
Data
  : String { FPCore.Abs.DStr $1 }
  | Expr { FPCore.Abs.DExpr $1 }
  | '(' ListData ')' { FPCore.Abs.DArr $2 }
  | '(' SymEx ListSymEx ')' { FPCore.Abs.DBind $2 $3 }

ListData :: { [FPCore.Abs.Data] }
ListData : {- empty -} { [] } | Data ListData { (:) $1 $2 }

ListSymEx :: { [FPCore.Abs.SymEx] }
ListSymEx : {- empty -} { [] } | SymEx ListSymEx { (:) $1 $2 }

SymEx :: { FPCore.Abs.SymEx }
SymEx
  : '[' Symbol Expr ']' { FPCore.Abs.SymExPair $2 $3 }
  | '(' Symbol Expr ')' { FPCore.Abs.SymExPair $2 $3 }

ListSymExEx :: { [FPCore.Abs.SymExEx] }
ListSymExEx
  : {- empty -} { [] } | SymExEx ListSymExEx { (:) $1 $2 }

SymExEx :: { FPCore.Abs.SymExEx }
SymExEx
  : '[' Symbol Expr Expr ']' { FPCore.Abs.SymExExTriple $2 $3 $4 }
  | '(' Symbol Expr Expr ')' { FPCore.Abs.SymExExTriple $2 $3 $4 }

Operation :: { FPCore.Abs.Operation }
Operation
  : '+' { FPCore.Abs.PlusOp }
  | '-' { FPCore.Abs.MinusOp }
  | '*' { FPCore.Abs.MulOp }
  | '/' { FPCore.Abs.DivOp }
  | 'fabs' { FPCore.Abs.FabsOp }
  | 'fma' { FPCore.Abs.FmaOp }
  | 'exp' { FPCore.Abs.ExpOp }
  | 'exp2' { FPCore.Abs.Exp2Op }
  | 'expm1' { FPCore.Abs.Expm1Op }
  | 'log' { FPCore.Abs.LogOp }
  | 'log10' { FPCore.Abs.Log10Op }
  | 'log2' { FPCore.Abs.Log2Op }
  | 'log1p' { FPCore.Abs.Log1pOp }
  | 'pow' { FPCore.Abs.PowOp }
  | 'sqrt' { FPCore.Abs.SqrtOp }
  | 'cbrt' { FPCore.Abs.CbrtOp }
  | 'hypot' { FPCore.Abs.HypotOp }
  | 'sin' { FPCore.Abs.SinOp }
  | 'cos' { FPCore.Abs.CosOp }
  | 'tan' { FPCore.Abs.TanOp }
  | 'asin' { FPCore.Abs.AsinOp }
  | 'acos' { FPCore.Abs.AcosOp }
  | 'atan' { FPCore.Abs.AtanOp }
  | 'atan2' { FPCore.Abs.Atan2Op }
  | 'sinh' { FPCore.Abs.SinhOp }
  | 'cosh' { FPCore.Abs.CoshOp }
  | 'tanh' { FPCore.Abs.TanhOp }
  | 'asinh' { FPCore.Abs.AsinhOp }
  | 'acosh' { FPCore.Abs.AcoshOp }
  | 'atanh' { FPCore.Abs.AtanhOp }
  | 'erf' { FPCore.Abs.ErfOp }
  | 'erfc' { FPCore.Abs.ErfcOp }
  | 'tgamma' { FPCore.Abs.TgammaOp }
  | 'lgamma' { FPCore.Abs.LgammaOp }
  | 'ceil' { FPCore.Abs.CeilOp }
  | 'floor' { FPCore.Abs.FloorOp }
  | 'fmod' { FPCore.Abs.FmodOp }
  | 'remainder' { FPCore.Abs.RemainderOp }
  | 'fmax' { FPCore.Abs.FmaxOp }
  | 'fmin' { FPCore.Abs.FminOp }
  | 'fdim' { FPCore.Abs.FdimOp }
  | 'copysign' { FPCore.Abs.CopysignOp }
  | 'trunc' { FPCore.Abs.TruncOp }
  | 'round' { FPCore.Abs.RoundOp }
  | 'nearbyint' { FPCore.Abs.NearbyintOp }
  | '<' { FPCore.Abs.LTOp }
  | '>' { FPCore.Abs.GTOp }
  | '<=' { FPCore.Abs.LTEOp }
  | '>=' { FPCore.Abs.GTEOp }
  | '==' { FPCore.Abs.EqualOp }
  | '!=' { FPCore.Abs.NEqualOp }
  | 'and' { FPCore.Abs.AndOp }
  | 'or' { FPCore.Abs.OrOp }
  | 'not' { FPCore.Abs.NotOp }
  | 'isfinite' { FPCore.Abs.IsfiniteOp }
  | 'isinf' { FPCore.Abs.IsinfOp }
  | 'isnan' { FPCore.Abs.IsnanOp }
  | 'isnormal' { FPCore.Abs.IsnormalOp }
  | 'signbit' { FPCore.Abs.SignbitOp }
  | 'dim' { FPCore.Abs.DimOp }
  | 'size' { FPCore.Abs.SizeOp }
  | 'ref' { FPCore.Abs.RefOp }

Constant :: { FPCore.Abs.Constant }
Constant
  : 'E' { FPCore.Abs.EConst }
  | 'LOG2E' { FPCore.Abs.LOG2EConst }
  | 'LOG10E' { FPCore.Abs.LOG10EConst }
  | 'LN2' { FPCore.Abs.LN2Const }
  | 'LN10' { FPCore.Abs.LN10Const }
  | 'PI' { FPCore.Abs.PIConst }
  | 'PI_2' { FPCore.Abs.PI_2Const }
  | 'PI_4' { FPCore.Abs.PI_4Const }
  | 'M_1_PI' { FPCore.Abs.M_1_PIConst }
  | 'M_2_PI' { FPCore.Abs.M_2_PIConst }
  | 'M_2_SQRTPI' { FPCore.Abs.M_2_SQRTPIConst }
  | 'SQRT2' { FPCore.Abs.SQRT2Const }
  | 'SQRT1_2' { FPCore.Abs.SQRT1_2Const }
  | 'INFINITY' { FPCore.Abs.INFINITYConst }
  | 'NAN' { FPCore.Abs.NANConst }
  | 'TRUE' { FPCore.Abs.TRUEConst }
  | 'FALSE' { FPCore.Abs.FALSEConst }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

