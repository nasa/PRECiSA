-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParFPCoreLang
  ( happyError
  , myLexer
  , pFPCore
  , pProperty
  , pListProperty
  , pArgument
  , pListArgument
  , pDimension
  , pListDimension
  , pExpr
  , pListExpr
  , pNumber
  , pData
  , pListData
  , pListSymEx
  , pSymEx
  , pListSymExEx
  , pSymExEx
  , pOperation
  , pConstant
  ) where

import Prelude

import qualified AbsFPCoreLang
import LexFPCoreLang

}

%name pFPCore FPCore
%name pProperty Property
%name pListProperty ListProperty
%name pArgument Argument
%name pListArgument ListArgument
%name pDimension Dimension
%name pListDimension ListDimension
%name pExpr Expr
%name pListExpr ListExpr
%name pNumber Number
%name pData Data
%name pListData ListData
%name pListSymEx ListSymEx
%name pSymEx SymEx
%name pListSymExEx ListSymExEx
%name pSymExEx SymExEx
%name pOperation Operation
%name pConstant Constant
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'             { PT _ (TS _ 1)        }
  '!='            { PT _ (TS _ 2)        }
  '('             { PT _ (TS _ 3)        }
  ')'             { PT _ (TS _ 4)        }
  '*'             { PT _ (TS _ 5)        }
  '*.f64'         { PT _ (TS _ 6)        }
  '+'             { PT _ (TS _ 7)        }
  '+.f64'         { PT _ (TS _ 8)        }
  '-'             { PT _ (TS _ 9)        }
  '-.f64'         { PT _ (TS _ 10)       }
  '/'             { PT _ (TS _ 11)       }
  '/.f64'         { PT _ (TS _ 12)       }
  ':'             { PT _ (TS _ 13)       }
  '<'             { PT _ (TS _ 14)       }
  '<='            { PT _ (TS _ 15)       }
  '=='            { PT _ (TS _ 16)       }
  '>'             { PT _ (TS _ 17)       }
  '>='            { PT _ (TS _ 18)       }
  'E'             { PT _ (TS _ 19)       }
  'FALSE'         { PT _ (TS _ 20)       }
  'FPCore'        { PT _ (TS _ 21)       }
  'INFINITY'      { PT _ (TS _ 22)       }
  'LN10'          { PT _ (TS _ 23)       }
  'LN2'           { PT _ (TS _ 24)       }
  'LOG10E'        { PT _ (TS _ 25)       }
  'LOG2E'         { PT _ (TS _ 26)       }
  'M_1_PI'        { PT _ (TS _ 27)       }
  'M_2_PI'        { PT _ (TS _ 28)       }
  'M_2_SQRTPI'    { PT _ (TS _ 29)       }
  'NAN'           { PT _ (TS _ 30)       }
  'PI'            { PT _ (TS _ 31)       }
  'PI_2'          { PT _ (TS _ 32)       }
  'PI_4'          { PT _ (TS _ 33)       }
  'SQRT1_2'       { PT _ (TS _ 34)       }
  'SQRT2'         { PT _ (TS _ 35)       }
  'TRUE'          { PT _ (TS _ 36)       }
  '['             { PT _ (TS _ 37)       }
  ']'             { PT _ (TS _ 38)       }
  'acos'          { PT _ (TS _ 39)       }
  'acos.f64'      { PT _ (TS _ 40)       }
  'acosh'         { PT _ (TS _ 41)       }
  'acosh.f64'     { PT _ (TS _ 42)       }
  'and'           { PT _ (TS _ 43)       }
  'array'         { PT _ (TS _ 44)       }
  'asin'          { PT _ (TS _ 45)       }
  'asin.f64'      { PT _ (TS _ 46)       }
  'asinh'         { PT _ (TS _ 47)       }
  'asinh.f64'     { PT _ (TS _ 48)       }
  'atan'          { PT _ (TS _ 49)       }
  'atan.f64'      { PT _ (TS _ 50)       }
  'atan2'         { PT _ (TS _ 51)       }
  'atan2.f64'     { PT _ (TS _ 52)       }
  'atanh'         { PT _ (TS _ 53)       }
  'atanh.f64'     { PT _ (TS _ 54)       }
  'cast'          { PT _ (TS _ 55)       }
  'cbrt'          { PT _ (TS _ 56)       }
  'cbrt.f64'      { PT _ (TS _ 57)       }
  'ceil'          { PT _ (TS _ 58)       }
  'ceil.f64'      { PT _ (TS _ 59)       }
  'copysign'      { PT _ (TS _ 60)       }
  'copysign.f64'  { PT _ (TS _ 61)       }
  'cos'           { PT _ (TS _ 62)       }
  'cos.f64'       { PT _ (TS _ 63)       }
  'cosh'          { PT _ (TS _ 64)       }
  'cosh.f64'      { PT _ (TS _ 65)       }
  'digits'        { PT _ (TS _ 66)       }
  'dim'           { PT _ (TS _ 67)       }
  'erf'           { PT _ (TS _ 68)       }
  'erf.f64'       { PT _ (TS _ 69)       }
  'erfc'          { PT _ (TS _ 70)       }
  'erfc.f64'      { PT _ (TS _ 71)       }
  'exp'           { PT _ (TS _ 72)       }
  'exp.f64'       { PT _ (TS _ 73)       }
  'exp2'          { PT _ (TS _ 74)       }
  'exp2.f64'      { PT _ (TS _ 75)       }
  'expm1'         { PT _ (TS _ 76)       }
  'expm1.f64'     { PT _ (TS _ 77)       }
  'fabs'          { PT _ (TS _ 78)       }
  'fabs.f64'      { PT _ (TS _ 79)       }
  'fdim'          { PT _ (TS _ 80)       }
  'fdim.f64'      { PT _ (TS _ 81)       }
  'floor'         { PT _ (TS _ 82)       }
  'floor.f64'     { PT _ (TS _ 83)       }
  'fma'           { PT _ (TS _ 84)       }
  'fma.f64'       { PT _ (TS _ 85)       }
  'fmax'          { PT _ (TS _ 86)       }
  'fmax.64'       { PT _ (TS _ 87)       }
  'fmin'          { PT _ (TS _ 88)       }
  'fmin.f64'      { PT _ (TS _ 89)       }
  'fmod'          { PT _ (TS _ 90)       }
  'fmod.f64'      { PT _ (TS _ 91)       }
  'for'           { PT _ (TS _ 92)       }
  'for*'          { PT _ (TS _ 93)       }
  'hypot'         { PT _ (TS _ 94)       }
  'hypot.f64'     { PT _ (TS _ 95)       }
  'if'            { PT _ (TS _ 96)       }
  'isfinite'      { PT _ (TS _ 97)       }
  'isinf'         { PT _ (TS _ 98)       }
  'isnan'         { PT _ (TS _ 99)       }
  'isnormal'      { PT _ (TS _ 100)      }
  'let'           { PT _ (TS _ 101)      }
  'let*'          { PT _ (TS _ 102)      }
  'lgamma'        { PT _ (TS _ 103)      }
  'lgamma.f64'    { PT _ (TS _ 104)      }
  'log'           { PT _ (TS _ 105)      }
  'log.f64'       { PT _ (TS _ 106)      }
  'log10'         { PT _ (TS _ 107)      }
  'log10.f64'     { PT _ (TS _ 108)      }
  'log1p'         { PT _ (TS _ 109)      }
  'log1p.f64'     { PT _ (TS _ 110)      }
  'log2'          { PT _ (TS _ 111)      }
  'log2.f64'      { PT _ (TS _ 112)      }
  'nearbyint'     { PT _ (TS _ 113)      }
  'not'           { PT _ (TS _ 114)      }
  'or'            { PT _ (TS _ 115)      }
  'pow'           { PT _ (TS _ 116)      }
  'pow.f64'       { PT _ (TS _ 117)      }
  'ref'           { PT _ (TS _ 118)      }
  'remainder'     { PT _ (TS _ 119)      }
  'remainder.f64' { PT _ (TS _ 120)      }
  'round'         { PT _ (TS _ 121)      }
  'round.f64'     { PT _ (TS _ 122)      }
  'signbit'       { PT _ (TS _ 123)      }
  'sin'           { PT _ (TS _ 124)      }
  'sin.f64'       { PT _ (TS _ 125)      }
  'sinh'          { PT _ (TS _ 126)      }
  'sinh.f64'      { PT _ (TS _ 127)      }
  'size'          { PT _ (TS _ 128)      }
  'sqrt'          { PT _ (TS _ 129)      }
  'sqrt.f64'      { PT _ (TS _ 130)      }
  'tan'           { PT _ (TS _ 131)      }
  'tan.f64'       { PT _ (TS _ 132)      }
  'tanh'          { PT _ (TS _ 133)      }
  'tanh.f64'      { PT _ (TS _ 134)      }
  'tensor'        { PT _ (TS _ 135)      }
  'tensor*'       { PT _ (TS _ 136)      }
  'tgamma'        { PT _ (TS _ 137)      }
  'tgamma.f64'    { PT _ (TS _ 138)      }
  'trunc'         { PT _ (TS _ 139)      }
  'trunc.f64'     { PT _ (TS _ 140)      }
  'while'         { PT _ (TS _ 141)      }
  'while*'        { PT _ (TS _ 142)      }
  L_quoted        { PT _ (TL $$)         }
  L_Rational      { PT _ (T_Rational $$) }
  L_DecNum        { PT _ (T_DecNum $$)   }
  L_HexNum        { PT _ (T_HexNum $$)   }
  L_Symbol        { PT _ (T_Symbol $$)   }

%%

String  :: { String }
String   : L_quoted { $1 }

Rational :: { AbsFPCoreLang.Rational }
Rational  : L_Rational { AbsFPCoreLang.Rational $1 }

DecNum :: { AbsFPCoreLang.DecNum }
DecNum  : L_DecNum { AbsFPCoreLang.DecNum $1 }

HexNum :: { AbsFPCoreLang.HexNum }
HexNum  : L_HexNum { AbsFPCoreLang.HexNum $1 }

Symbol :: { AbsFPCoreLang.Symbol }
Symbol  : L_Symbol { AbsFPCoreLang.Symbol $1 }

FPCore :: { AbsFPCoreLang.FPCore }
FPCore
  : '(' 'FPCore' Symbol '(' ListArgument ')' ListProperty Expr ')' { AbsFPCoreLang.FProgram $3 $5 $7 $8 }
  | '(' 'FPCore' '(' ListArgument ')' ListProperty Expr ')' { AbsFPCoreLang.FProgramSymbless $4 $6 $7 }

Property :: { AbsFPCoreLang.Property }
Property : ':' Symbol Data { AbsFPCoreLang.Prop $2 $3 }

ListProperty :: { [AbsFPCoreLang.Property] }
ListProperty
  : {- empty -} { [] } | Property ListProperty { (:) $1 $2 }

Argument :: { AbsFPCoreLang.Argument }
Argument
  : Symbol { AbsFPCoreLang.ASym $1 }
  | '(' Symbol ListDimension ')' { AbsFPCoreLang.ASymDim $2 $3 }
  | '(' '!' ListProperty Symbol ListDimension ')' { AbsFPCoreLang.AProp $3 $4 $5 }

ListArgument :: { [AbsFPCoreLang.Argument] }
ListArgument
  : {- empty -} { [] } | Argument ListArgument { (:) $1 $2 }

Dimension :: { AbsFPCoreLang.Dimension }
Dimension
  : Symbol { AbsFPCoreLang.DimSym $1 }
  | Number { AbsFPCoreLang.DimNum $1 }

ListDimension :: { [AbsFPCoreLang.Dimension] }
ListDimension
  : {- empty -} { [] } | Dimension ListDimension { (:) $1 $2 }

Expr :: { AbsFPCoreLang.Expr }
Expr
  : Number { AbsFPCoreLang.ExNum $1 }
  | Constant { AbsFPCoreLang.ExConst $1 }
  | Symbol { AbsFPCoreLang.ExSym $1 }
  | '(' Operation Expr ListExpr ')' { AbsFPCoreLang.ExOp $2 $3 $4 }
  | '(' 'if' Expr Expr Expr ')' { AbsFPCoreLang.ExIf $3 $4 $5 }
  | '(' 'let' '(' ListSymEx ')' Expr ')' { AbsFPCoreLang.ExLet $4 $6 }
  | '(' 'let*' '(' ListSymEx ')' Expr ')' { AbsFPCoreLang.ExLetStar $4 $6 }
  | '(' 'while' Expr '(' ListSymExEx ')' Expr ')' { AbsFPCoreLang.ExWhile $3 $5 $7 }
  | '(' 'while*' Expr '(' ListSymExEx ')' Expr ')' { AbsFPCoreLang.ExWhileStar $3 $5 $7 }
  | '(' 'for' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { AbsFPCoreLang.ExFor $4 $7 $9 }
  | '(' 'for*' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { AbsFPCoreLang.ExForStar $4 $7 $9 }
  | '(' 'tensor' '(' ListSymEx ')' Expr ')' { AbsFPCoreLang.ExTensor $4 $6 }
  | '(' 'tensor*' '(' ListSymEx ')' '(' ListSymExEx ')' Expr ')' { AbsFPCoreLang.ExTensorStar $4 $7 $9 }
  | '(' 'cast' Expr ')' { AbsFPCoreLang.ExCast $3 }
  | '(' 'array' ListExpr ')' { AbsFPCoreLang.ExArray $3 }
  | '(' '!' ListProperty Expr ')' { AbsFPCoreLang.ExProp $3 $4 }

ListExpr :: { [AbsFPCoreLang.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Number :: { AbsFPCoreLang.Number }
Number
  : Rational { AbsFPCoreLang.NRat $1 }
  | DecNum { AbsFPCoreLang.NDecNum $1 }
  | HexNum { AbsFPCoreLang.NHexNum $1 }
  | '(' 'digits' DecNum DecNum DecNum ')' { AbsFPCoreLang.NDigits $3 $4 $5 }

Data :: { AbsFPCoreLang.Data }
Data
  : String { AbsFPCoreLang.DStr $1 }
  | Expr { AbsFPCoreLang.DExpr $1 }
  | '(' ListData ')' { AbsFPCoreLang.DArr $2 }
  | '(' SymEx ListSymEx ')' { AbsFPCoreLang.DBind $2 $3 }

ListData :: { [AbsFPCoreLang.Data] }
ListData : {- empty -} { [] } | Data ListData { (:) $1 $2 }

ListSymEx :: { [AbsFPCoreLang.SymEx] }
ListSymEx : {- empty -} { [] } | SymEx ListSymEx { (:) $1 $2 }

SymEx :: { AbsFPCoreLang.SymEx }
SymEx
  : '[' Symbol Expr ']' { AbsFPCoreLang.SymExPair $2 $3 }
  | '(' Symbol Expr ')' { AbsFPCoreLang.SymExPair $2 $3 }

ListSymExEx :: { [AbsFPCoreLang.SymExEx] }
ListSymExEx
  : {- empty -} { [] } | SymExEx ListSymExEx { (:) $1 $2 }

SymExEx :: { AbsFPCoreLang.SymExEx }
SymExEx
  : '[' Symbol Expr Expr ']' { AbsFPCoreLang.SymExExTriple $2 $3 $4 }
  | '(' Symbol Expr Expr ')' { AbsFPCoreLang.SymExExTriple $2 $3 $4 }

Operation :: { AbsFPCoreLang.Operation }
Operation
  : '+' { AbsFPCoreLang.PlusOp }
  | '+.f64' { AbsFPCoreLang.PlusOp }
  | '-' { AbsFPCoreLang.MinusOp }
  | '-.f64' { AbsFPCoreLang.MinusOp }
  | '*' { AbsFPCoreLang.MulOp }
  | '*.f64' { AbsFPCoreLang.MulOp }
  | '/' { AbsFPCoreLang.DivOp }
  | '/.f64' { AbsFPCoreLang.DivOp }
  | 'fabs' { AbsFPCoreLang.FabsOp }
  | 'fabs.f64' { AbsFPCoreLang.FabsOp }
  | 'fma' { AbsFPCoreLang.FmaOp }
  | 'fma.f64' { AbsFPCoreLang.FmaOp }
  | 'exp' { AbsFPCoreLang.ExpOp }
  | 'exp.f64' { AbsFPCoreLang.ExpOp }
  | 'exp2' { AbsFPCoreLang.Exp2Op }
  | 'exp2.f64' { AbsFPCoreLang.Exp2Op }
  | 'expm1' { AbsFPCoreLang.Expm1Op }
  | 'expm1.f64' { AbsFPCoreLang.Expm1Op }
  | 'log' { AbsFPCoreLang.LogOp }
  | 'log.f64' { AbsFPCoreLang.LogOp }
  | 'log10' { AbsFPCoreLang.Log10Op }
  | 'log10.f64' { AbsFPCoreLang.Log10Op }
  | 'log2' { AbsFPCoreLang.Log2Op }
  | 'log2.f64' { AbsFPCoreLang.Log2Op }
  | 'log1p' { AbsFPCoreLang.Log1pOp }
  | 'log1p.f64' { AbsFPCoreLang.Log1pOp }
  | 'pow' { AbsFPCoreLang.PowOp }
  | 'pow.f64' { AbsFPCoreLang.PowOp }
  | 'sqrt' { AbsFPCoreLang.SqrtOp }
  | 'sqrt.f64' { AbsFPCoreLang.SqrtOp }
  | 'cbrt' { AbsFPCoreLang.CbrtOp }
  | 'cbrt.f64' { AbsFPCoreLang.CbrtOp }
  | 'hypot' { AbsFPCoreLang.HypotOp }
  | 'hypot.f64' { AbsFPCoreLang.HypotOp }
  | 'sin' { AbsFPCoreLang.SinOp }
  | 'sin.f64' { AbsFPCoreLang.SinOp }
  | 'cos' { AbsFPCoreLang.CosOp }
  | 'cos.f64' { AbsFPCoreLang.CosOp }
  | 'tan' { AbsFPCoreLang.TanOp }
  | 'tan.f64' { AbsFPCoreLang.TanOp }
  | 'asin' { AbsFPCoreLang.AsinOp }
  | 'asin.f64' { AbsFPCoreLang.AsinOp }
  | 'acos' { AbsFPCoreLang.AcosOp }
  | 'acos.f64' { AbsFPCoreLang.AcosOp }
  | 'atan' { AbsFPCoreLang.AtanOp }
  | 'atan.f64' { AbsFPCoreLang.AtanOp }
  | 'atan2' { AbsFPCoreLang.Atan2Op }
  | 'atan2.f64' { AbsFPCoreLang.Atan2Op }
  | 'sinh' { AbsFPCoreLang.SinhOp }
  | 'sinh.f64' { AbsFPCoreLang.SinhOp }
  | 'cosh' { AbsFPCoreLang.CoshOp }
  | 'cosh.f64' { AbsFPCoreLang.CoshOp }
  | 'tanh' { AbsFPCoreLang.TanhOp }
  | 'tanh.f64' { AbsFPCoreLang.TanhOp }
  | 'asinh' { AbsFPCoreLang.AsinhOp }
  | 'asinh.f64' { AbsFPCoreLang.AsinhOp }
  | 'acosh' { AbsFPCoreLang.AcoshOp }
  | 'acosh.f64' { AbsFPCoreLang.AcoshOp }
  | 'atanh' { AbsFPCoreLang.AtanhOp }
  | 'atanh.f64' { AbsFPCoreLang.AtanhOp }
  | 'erf' { AbsFPCoreLang.ErfOp }
  | 'erf.f64' { AbsFPCoreLang.ErfOp }
  | 'erfc' { AbsFPCoreLang.ErfcOp }
  | 'erfc.f64' { AbsFPCoreLang.ErfcOp }
  | 'tgamma' { AbsFPCoreLang.TgammaOp }
  | 'tgamma.f64' { AbsFPCoreLang.TgammaOp }
  | 'lgamma' { AbsFPCoreLang.LgammaOp }
  | 'lgamma.f64' { AbsFPCoreLang.LgammaOp }
  | 'ceil' { AbsFPCoreLang.CeilOp }
  | 'ceil.f64' { AbsFPCoreLang.CeilOp }
  | 'floor' { AbsFPCoreLang.FloorOp }
  | 'floor.f64' { AbsFPCoreLang.FloorOp }
  | 'fmod' { AbsFPCoreLang.FmodOp }
  | 'fmod.f64' { AbsFPCoreLang.FmodOp }
  | 'remainder' { AbsFPCoreLang.RemainderOp }
  | 'remainder.f64' { AbsFPCoreLang.RemainderOp }
  | 'fmax' { AbsFPCoreLang.FmaxOp }
  | 'fmax.64' { AbsFPCoreLang.FmaxOp }
  | 'fmin' { AbsFPCoreLang.FminOp }
  | 'fmin.f64' { AbsFPCoreLang.FminOp }
  | 'fdim' { AbsFPCoreLang.FdimOp }
  | 'fdim.f64' { AbsFPCoreLang.FdimOp }
  | 'copysign' { AbsFPCoreLang.CopysignOp }
  | 'copysign.f64' { AbsFPCoreLang.CopysignOp }
  | 'trunc' { AbsFPCoreLang.TruncOp }
  | 'trunc.f64' { AbsFPCoreLang.TruncOp }
  | 'round' { AbsFPCoreLang.RoundOp }
  | 'round.f64' { AbsFPCoreLang.RoundOp }
  | 'nearbyint' { AbsFPCoreLang.NearbyintOp }
  | '<' { AbsFPCoreLang.LTOp }
  | '>' { AbsFPCoreLang.GTOp }
  | '<=' { AbsFPCoreLang.LTEOp }
  | '>=' { AbsFPCoreLang.GTEOp }
  | '==' { AbsFPCoreLang.EqualOp }
  | '!=' { AbsFPCoreLang.NEqualOp }
  | 'and' { AbsFPCoreLang.AndOp }
  | 'or' { AbsFPCoreLang.OrOp }
  | 'not' { AbsFPCoreLang.NotOp }
  | 'isfinite' { AbsFPCoreLang.IsfiniteOp }
  | 'isinf' { AbsFPCoreLang.IsinfOp }
  | 'isnan' { AbsFPCoreLang.IsnanOp }
  | 'isnormal' { AbsFPCoreLang.IsnormalOp }
  | 'signbit' { AbsFPCoreLang.SignbitOp }
  | 'dim' { AbsFPCoreLang.DimOp }
  | 'size' { AbsFPCoreLang.SizeOp }
  | 'ref' { AbsFPCoreLang.RefOp }

Constant :: { AbsFPCoreLang.Constant }
Constant
  : 'E' { AbsFPCoreLang.EConst }
  | 'LOG2E' { AbsFPCoreLang.LOG2EConst }
  | 'LOG10E' { AbsFPCoreLang.LOG10EConst }
  | 'LN2' { AbsFPCoreLang.LN2Const }
  | 'LN10' { AbsFPCoreLang.LN10Const }
  | 'PI' { AbsFPCoreLang.PIConst }
  | 'PI_2' { AbsFPCoreLang.PI_2Const }
  | 'PI_4' { AbsFPCoreLang.PI_4Const }
  | 'M_1_PI' { AbsFPCoreLang.M_1_PIConst }
  | 'M_2_PI' { AbsFPCoreLang.M_2_PIConst }
  | 'M_2_SQRTPI' { AbsFPCoreLang.M_2_SQRTPIConst }
  | 'SQRT2' { AbsFPCoreLang.SQRT2Const }
  | 'SQRT1_2' { AbsFPCoreLang.SQRT1_2Const }
  | 'INFINITY' { AbsFPCoreLang.INFINITYConst }
  | 'NAN' { AbsFPCoreLang.NANConst }
  | 'TRUE' { AbsFPCoreLang.TRUEConst }
  | 'FALSE' { AbsFPCoreLang.FALSEConst }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

