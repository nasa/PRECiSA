-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParRawPVSLang
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified AbsRawPVSLang
import LexRawPVSLang

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#)'        { PT _ (TS _ 1)  }
  '#]'        { PT _ (TS _ 2)  }
  '('         { PT _ (TS _ 3)  }
  '(#'        { PT _ (TS _ 4)  }
  ')'         { PT _ (TS _ 5)  }
  '*'         { PT _ (TS _ 6)  }
  '+'         { PT _ (TS _ 7)  }
  ','         { PT _ (TS _ 8)  }
  '-'         { PT _ (TS _ 9)  }
  '->'        { PT _ (TS _ 10) }
  '/'         { PT _ (TS _ 11) }
  '/='        { PT _ (TS _ 12) }
  ':'         { PT _ (TS _ 13) }
  ':='        { PT _ (TS _ 14) }
  '<'         { PT _ (TS _ 15) }
  '<='        { PT _ (TS _ 16) }
  '='         { PT _ (TS _ 17) }
  '>'         { PT _ (TS _ 18) }
  '>='        { PT _ (TS _ 19) }
  'AND'       { PT _ (TS _ 20) }
  'ARRAY'     { PT _ (TS _ 21) }
  'BEGIN'     { PT _ (TS _ 22) }
  'ELSE'      { PT _ (TS _ 23) }
  'ELSIF'     { PT _ (TS _ 24) }
  'END'       { PT _ (TS _ 25) }
  'ENDIF'     { PT _ (TS _ 26) }
  'FALSE'     { PT _ (TS _ 27) }
  'FUNCTION'  { PT _ (TS _ 28) }
  'IF'        { PT _ (TS _ 29) }
  'IMPORTING' { PT _ (TS _ 30) }
  'IN'        { PT _ (TS _ 31) }
  'LAMBDA'    { PT _ (TS _ 32) }
  'LET'       { PT _ (TS _ 33) }
  'NOT'       { PT _ (TS _ 34) }
  'OR'        { PT _ (TS _ 35) }
  'SUBRANGE'  { PT _ (TS _ 36) }
  'THEN'      { PT _ (TS _ 37) }
  'THEORY'    { PT _ (TS _ 38) }
  'TRUE'      { PT _ (TS _ 39) }
  'WITH'      { PT _ (TS _ 40) }
  '['         { PT _ (TS _ 41) }
  '[#'        { PT _ (TS _ 42) }
  ']'         { PT _ (TS _ 43) }
  '^'         { PT _ (TS _ 44) }
  '`'         { PT _ (TS _ 45) }
  'below'     { PT _ (TS _ 46) }
  'for'       { PT _ (TS _ 47) }
  'for_down'  { PT _ (TS _ 48) }
  'lambda'    { PT _ (TS _ 49) }
  'list'      { PT _ (TS _ 50) }
  '|'         { PT _ (TS _ 51) }
  L_doubl     { PT _ (TD $$)   }
  L_integ     { PT _ (TI $$)   }
  L_Id        { PT _ (T_Id $$) }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Id :: { AbsRawPVSLang.Id }
Id  : L_Id { AbsRawPVSLang.Id $1 }

ListId :: { [AbsRawPVSLang.Id] }
ListId : Id { (:[]) $1 } | Id ',' ListId { (:) $1 $3 }

ElsIf :: { AbsRawPVSLang.ElsIf }
ElsIf : 'ELSIF' Expr 'THEN' Expr { AbsRawPVSLang.ElsIf $2 $4 }

ListElsIf :: { [AbsRawPVSLang.ElsIf] }
ListElsIf : ElsIf { (:[]) $1 } | ElsIf ListElsIf { (:) $1 $2 }

LetElem :: { AbsRawPVSLang.LetElem }
LetElem
  : Id '=' Expr { AbsRawPVSLang.LetElem $1 $3 }
  | Id ':' Type '=' Expr { AbsRawPVSLang.LetElemType $1 $3 $5 }

ListLetElem :: { [AbsRawPVSLang.LetElem] }
ListLetElem
  : LetElem { (:[]) $1 } | LetElem ',' ListLetElem { (:) $1 $3 }

RecordElem :: { AbsRawPVSLang.RecordElem }
RecordElem : Id ':=' Expr { AbsRawPVSLang.RecordElem $1 $3 }

ListRecordElem :: { [AbsRawPVSLang.RecordElem] }
ListRecordElem
  : RecordElem { (:[]) $1 }
  | RecordElem ',' ListRecordElem { (:) $1 $3 }

LambdaKeyWord :: { AbsRawPVSLang.LambdaKeyWord }
LambdaKeyWord
  : 'LAMBDA' { AbsRawPVSLang.LambdaWord1 }
  | 'lambda' { AbsRawPVSLang.LambdaWord2 }

LambdaExpr :: { AbsRawPVSLang.LambdaExpr }
LambdaExpr
  : LambdaKeyWord '(' Id ':' 'SUBRANGE' '(' Expr ',' Expr ')' ',' Id ':' Type ')' ':' Expr { AbsRawPVSLang.Lambda $1 $3 $7 $9 $12 $14 $17 }

ListExpr :: { [AbsRawPVSLang.Expr] }
ListExpr : Expr { (:[]) $1 } | Expr ',' ListExpr { (:) $1 $3 }

Expr :: { AbsRawPVSLang.Expr }
Expr
  : Expr1 { $1 }
  | 'LET' ListLetElem 'IN' Expr { AbsRawPVSLang.Let $2 $4 }

Expr1 :: { AbsRawPVSLang.Expr }
Expr1 : Expr2 { $1 } | Expr1 'OR' Expr2 { AbsRawPVSLang.Or $1 $3 }

Expr2 :: { AbsRawPVSLang.Expr }
Expr2
  : Expr3 { $1 } | Expr2 'AND' Expr3 { AbsRawPVSLang.And $1 $3 }

Expr3 :: { AbsRawPVSLang.Expr }
Expr3 : Expr4 { $1 } | 'NOT' Expr4 { AbsRawPVSLang.Not $2 }

Expr4 :: { AbsRawPVSLang.Expr }
Expr4
  : Expr5 { $1 }
  | Expr5 '=' Expr5 { AbsRawPVSLang.Eq $1 $3 }
  | Expr5 '/=' Expr5 { AbsRawPVSLang.Neq $1 $3 }
  | Expr5 '<' Expr5 { AbsRawPVSLang.Lt $1 $3 }
  | Expr5 '<=' Expr5 { AbsRawPVSLang.LtE $1 $3 }
  | Expr5 '>' Expr5 { AbsRawPVSLang.Gt $1 $3 }
  | Expr5 '>=' Expr5 { AbsRawPVSLang.GtE $1 $3 }

Expr5 :: { AbsRawPVSLang.Expr }
Expr5
  : Expr6 { $1 }
  | Expr5 '+' Expr6 { AbsRawPVSLang.ExprAdd $1 $3 }
  | Expr5 '-' Expr6 { AbsRawPVSLang.ExprSub $1 $3 }

Expr6 :: { AbsRawPVSLang.Expr }
Expr6
  : Expr7 { $1 }
  | Expr6 '*' Expr7 { AbsRawPVSLang.ExprMul $1 $3 }
  | Expr6 '/' Expr7 { AbsRawPVSLang.ExprDiv $1 $3 }
  | Expr6 'WITH' '[' Expr ':=' Expr ']' { AbsRawPVSLang.With $1 $4 $6 }

Expr7 :: { AbsRawPVSLang.Expr }
Expr7 : Expr8 { $1 } | '-' Expr8 { AbsRawPVSLang.ExprNeg $2 }

Expr8 :: { AbsRawPVSLang.Expr }
Expr8
  : Expr9 { $1 } | Expr9 '^' Expr8 { AbsRawPVSLang.ExprPow $1 $3 }

Expr9 :: { AbsRawPVSLang.Expr }
Expr9
  : Expr10 { $1 }
  | 'IF' Expr 'THEN' Expr 'ELSE' Expr 'ENDIF' { AbsRawPVSLang.If $2 $4 $6 }
  | 'IF' Expr 'THEN' Expr ListElsIf 'ELSE' Expr 'ENDIF' { AbsRawPVSLang.ListIf $2 $4 $5 $7 }
  | 'for' '(' Expr ',' Expr ',' Expr ',' LambdaExpr ')' { AbsRawPVSLang.For $3 $5 $7 $9 }
  | 'for_down' '(' Expr ',' Expr ',' Expr ',' LambdaExpr ')' { AbsRawPVSLang.ForDown $3 $5 $7 $9 }

Expr10 :: { AbsRawPVSLang.Expr }
Expr10
  : Expr11 { $1 }
  | Id '`' Integer { AbsRawPVSLang.TupleIndex $1 $3 }
  | Id '`' Id { AbsRawPVSLang.RecordField $1 $3 }
  | Id '(' ListExpr ')' '`' Integer { AbsRawPVSLang.TupleFunIndex $1 $3 $6 }
  | Id '(' ListExpr ')' '`' Id { AbsRawPVSLang.RecordFunField $1 $3 $6 }
  | '(#' ListRecordElem '#)' { AbsRawPVSLang.RecordExpr $2 }
  | '(' ListExpr ')' { AbsRawPVSLang.TupleExpr $2 }
  | Id '(' ListExpr ')' { AbsRawPVSLang.Call $1 $3 }
  | Id { AbsRawPVSLang.ExprId $1 }
  | Integer { AbsRawPVSLang.Int $1 }
  | Double { AbsRawPVSLang.Rat $1 }
  | 'TRUE' { AbsRawPVSLang.BTrue }
  | 'FALSE' { AbsRawPVSLang.BFalse }

Expr11 :: { AbsRawPVSLang.Expr }
Expr11 : '(' Expr ')' { $2 }

FieldDecls :: { AbsRawPVSLang.FieldDecls }
FieldDecls : Id ':' Type { AbsRawPVSLang.FieldDecls $1 $3 }

ListType :: { [AbsRawPVSLang.Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }

ListFieldDecls :: { [AbsRawPVSLang.FieldDecls] }
ListFieldDecls
  : FieldDecls { (:[]) $1 }
  | FieldDecls ',' ListFieldDecls { (:) $1 $3 }

Type :: { AbsRawPVSLang.Type }
Type
  : Id { AbsRawPVSLang.TypeSimple $1 }
  | Id '(' Integer ',' Integer ')' { AbsRawPVSLang.ParametricTypeBi $1 $3 $5 }
  | 'below' '(' Expr ')' { AbsRawPVSLang.TypeBelow $3 }
  | '[#' ListFieldDecls '#]' { AbsRawPVSLang.TypeRecord $2 }
  | '[' ListType ']' { AbsRawPVSLang.TypeTuple $2 }
  | 'ARRAY' '[' ListType '->' Type ']' { AbsRawPVSLang.TypeArray $3 $5 }
  | 'FUNCTION' '[' ListType '->' Type ']' { AbsRawPVSLang.TypeFun $3 $5 }
  | '[' ListType '->' Type ']' { AbsRawPVSLang.TypeFun2 $2 $4 }
  | 'list' '[' Type ']' { AbsRawPVSLang.TypeList $3 }

ListArg :: { [AbsRawPVSLang.Arg] }
ListArg : Arg { (:[]) $1 } | Arg ',' ListArg { (:) $1 $3 }

Arg :: { AbsRawPVSLang.Arg }
Arg
  : ListId ':' Type { AbsRawPVSLang.FArg $1 $3 }
  | ListId ':' Type '|' Expr { AbsRawPVSLang.FArgGuard $1 $3 $5 }

Args :: { AbsRawPVSLang.Args }
Args
  : ListArg { AbsRawPVSLang.FArgs $1 }
  | ListId { AbsRawPVSLang.FArgsNoType $1 }

ListDecl :: { [AbsRawPVSLang.Decl] }
ListDecl : Decl { (:[]) $1 } | Decl ListDecl { (:) $1 $2 }

Decl :: { AbsRawPVSLang.Decl }
Decl
  : Id '(' Args ')' ':' Type '=' Expr { AbsRawPVSLang.DeclN $1 $3 $6 $8 }
  | Id ':' Type '=' Expr { AbsRawPVSLang.Decl0 $1 $3 $5 }

Imp :: { AbsRawPVSLang.Imp }
Imp : 'IMPORTING' ListId { AbsRawPVSLang.LibImp $2 }

Program :: { AbsRawPVSLang.Program }
Program
  : Id ':' 'THEORY' 'BEGIN' Imp ListDecl 'END' Id { AbsRawPVSLang.ProgImp $1 $5 $6 $8 }
  | Id ':' 'THEORY' 'BEGIN' ListDecl 'END' Id { AbsRawPVSLang.Prog $1 $5 $7 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

