-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParRawPVSLang where
import AbsRawPVSLang
import LexRawPVSLang
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '/' { PT _ (TS _ 7) }
  '/=' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  '<' { PT _ (TS _ 10) }
  '<=' { PT _ (TS _ 11) }
  '=' { PT _ (TS _ 12) }
  '>' { PT _ (TS _ 13) }
  '>=' { PT _ (TS _ 14) }
  'AND' { PT _ (TS _ 15) }
  'BEGIN' { PT _ (TS _ 16) }
  'ELSE' { PT _ (TS _ 17) }
  'ELSIF' { PT _ (TS _ 18) }
  'END' { PT _ (TS _ 19) }
  'ENDIF' { PT _ (TS _ 20) }
  'FALSE' { PT _ (TS _ 21) }
  'IF' { PT _ (TS _ 22) }
  'IMPORTING' { PT _ (TS _ 23) }
  'IN' { PT _ (TS _ 24) }
  'LET' { PT _ (TS _ 25) }
  'NOT' { PT _ (TS _ 26) }
  'OR' { PT _ (TS _ 27) }
  'THEN' { PT _ (TS _ 28) }
  'THEORY' { PT _ (TS _ 29) }
  'TRUE' { PT _ (TS _ 30) }
  'VAR' { PT _ (TS _ 31) }
  '^' { PT _ (TS _ 32) }
  'for' { PT _ (TS _ 33) }
  'subrange' { PT _ (TS _ 34) }
  '|' { PT _ (TS _ 35) }
  L_integ  { PT _ (TI $$) }
  L_doubl  { PT _ (TD $$) }
  L_Id { PT _ (T_Id $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Double  :: { Double }
Double   : L_doubl  { (read ( $1)) :: Double }

Id :: { Id}
Id  : L_Id { Id ($1)}

ListId :: { [Id] }
ListId : Id { (:[]) $1 } | Id ',' ListId { (:) $1 $3 }
ElsIf :: { ElsIf }
ElsIf : 'ELSIF' Expr 'THEN' Expr { AbsRawPVSLang.ElsIf $2 $4 }
ListElsIf :: { [ElsIf] }
ListElsIf : ElsIf { (:[]) $1 } | ElsIf ListElsIf { (:) $1 $2 }
LetElem :: { LetElem }
LetElem : Id '=' Expr { AbsRawPVSLang.LetElem $1 $3 }
        | Id ':' Id '=' Expr { AbsRawPVSLang.LetElemType $1 $3 $5 }
ListLetElem :: { [LetElem] }
ListLetElem : LetElem { (:[]) $1 }
            | LetElem ',' ListLetElem { (:) $1 $3 }
ListExpr :: { [Expr] }
ListExpr : Expr { (:[]) $1 } | Expr ',' ListExpr { (:) $1 $3 }
Expr :: { Expr }
Expr : Expr1 { $1 }
     | 'LET' ListLetElem 'IN' Expr { AbsRawPVSLang.Let $2 $4 }
Expr1 :: { Expr }
Expr1 : Expr2 { $1 } | Expr1 'OR' Expr2 { AbsRawPVSLang.Or $1 $3 }
Expr2 :: { Expr }
Expr2 : Expr3 { $1 }
      | Expr2 'AND' Expr3 { AbsRawPVSLang.And $1 $3 }
Expr3 :: { Expr }
Expr3 : Expr4 { $1 } | 'NOT' Expr4 { AbsRawPVSLang.Not $2 }
Expr4 :: { Expr }
Expr4 : Expr5 { $1 }
      | Expr5 '=' Expr5 { AbsRawPVSLang.Eq $1 $3 }
      | Expr5 '/=' Expr5 { AbsRawPVSLang.Neq $1 $3 }
      | Expr5 '<' Expr5 { AbsRawPVSLang.Lt $1 $3 }
      | Expr5 '<=' Expr5 { AbsRawPVSLang.LtE $1 $3 }
      | Expr5 '>' Expr5 { AbsRawPVSLang.Gt $1 $3 }
      | Expr5 '>=' Expr5 { AbsRawPVSLang.GtE $1 $3 }
Expr5 :: { Expr }
Expr5 : Expr6 { $1 }
      | Expr5 '+' Expr6 { AbsRawPVSLang.ExprAdd $1 $3 }
      | Expr5 '-' Expr6 { AbsRawPVSLang.ExprSub $1 $3 }
Expr6 :: { Expr }
Expr6 : Expr7 { $1 }
      | Expr6 '*' Expr7 { AbsRawPVSLang.ExprMul $1 $3 }
      | Expr6 '/' Expr7 { AbsRawPVSLang.ExprDiv $1 $3 }
Expr7 :: { Expr }
Expr7 : Expr8 { $1 } | '-' Expr8 { AbsRawPVSLang.ExprNeg $2 }
Expr8 :: { Expr }
Expr8 : Expr9 { $1 }
      | Expr9 '^' Expr8 { AbsRawPVSLang.ExprPow $1 $3 }
Expr9 :: { Expr }
Expr9 : Expr10 { $1 }
      | 'IF' Expr 'THEN' Expr 'ELSE' Expr 'ENDIF' { AbsRawPVSLang.If $2 $4 $6 }
      | 'IF' Expr 'THEN' Expr ListElsIf 'ELSE' Expr 'ENDIF' { AbsRawPVSLang.ListIf $2 $4 $5 $7 }
      | 'for' '(' Integer ',' Integer ',' Expr ',' Id ')' { AbsRawPVSLang.For $3 $5 $7 $9 }
Expr10 :: { Expr }
Expr10 : Expr11 { $1 }
       | Id '(' ListExpr ')' { AbsRawPVSLang.Call $1 $3 }
       | Id { AbsRawPVSLang.ExprId $1 }
       | Integer { AbsRawPVSLang.Int $1 }
       | Double { AbsRawPVSLang.Rat $1 }
       | 'TRUE' { AbsRawPVSLang.BTrue }
       | 'FALSE' { AbsRawPVSLang.BFalse }
Expr11 :: { Expr }
Expr11 : '(' Expr ')' { $2 }
Subrange :: { Subrange }
Subrange : 'subrange' '(' Integer ',' Integer ')' { AbsRawPVSLang.SubrageType $3 $5 }
ListArg :: { [Arg] }
ListArg : Arg { (:[]) $1 } | Arg ',' ListArg { (:) $1 $3 }
Arg :: { Arg }
Arg : ListId ':' Id { AbsRawPVSLang.FArg $1 $3 }
    | ListId ':' Subrange { AbsRawPVSLang.FArgSubrange $1 $3 }
    | ListId ':' Id '|' Expr { AbsRawPVSLang.FArgGuard $1 $3 $5 }
Args :: { Args }
Args : ListArg { AbsRawPVSLang.FArgs $1 }
     | ListId { AbsRawPVSLang.FArgsNoType $1 }
ListDecl :: { [Decl] }
ListDecl : Decl { (:[]) $1 } | Decl ListDecl { (:) $1 $2 }
Decl :: { Decl }
Decl : Id '(' Args ')' ':' Id '=' Expr { AbsRawPVSLang.DeclN $1 $3 $6 $8 }
     | Id ':' Id '=' Expr { AbsRawPVSLang.Decl0 $1 $3 $5 }
Imp :: { Imp }
Imp : 'IMPORTING' ListId { AbsRawPVSLang.LibImp $2 }
VarDecl :: { VarDecl }
VarDecl : Id ':' 'VAR' Id { AbsRawPVSLang.VarDeclaration $1 $4 }
ListVarDecl :: { [VarDecl] }
ListVarDecl : {- empty -} { [] }
            | ListVarDecl VarDecl { flip (:) $1 $2 }
Program :: { Program }
Program : Id ':' 'THEORY' 'BEGIN' Imp ListVarDecl ListDecl 'END' Id { AbsRawPVSLang.ProgImp $1 $5 (reverse $6) $7 $9 }
        | Id ':' 'THEORY' 'BEGIN' ListVarDecl ListDecl 'END' Id { AbsRawPVSLang.Prog $1 (reverse $5) $6 $8 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

