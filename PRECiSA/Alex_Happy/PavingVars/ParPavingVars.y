-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParPavingVars where
import AbsPavingVars
import LexPavingVars
import ErrM

}

%name pVarTupleListProg VarTupleListProg
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  ':' { PT _ (TS _ 4) }
  '[' { PT _ (TS _ 5) }
  ']' { PT _ (TS _ 6) }

L_VarId { PT _ (T_VarId $$) }
L_NonVarId { PT _ (T_NonVarId $$) }


%%

VarId    :: { VarId} : L_VarId { VarId ($1)}
NonVarId    :: { NonVarId} : L_NonVarId { NonVarId ($1)}

ListVarId :: { [VarId] }
ListVarId : VarId { (:[]) $1 } | VarId ',' ListVarId { (:) $1 $3 }
VarTuple :: { VarTuple }
VarTuple : '(' VarId ',' VarId ')' { AbsPavingVars.VarTupleBi $2 $4 }
         | '(' VarId ',' VarId ',' VarId ')' { AbsPavingVars.VarTupleTri $2 $4 $6 }
ListVarTuple :: { [VarTuple] }
ListVarTuple : {- empty -} { [] }
             | VarTuple { (:[]) $1 }
             | VarTuple ',' ListVarTuple { (:) $1 $3 }
VarTupleList :: { VarTupleList }
VarTupleList : '[' ListVarTuple ']' { AbsPavingVars.VarTupleList $2 }
VarTupleListBind :: { VarTupleListBind }
VarTupleListBind : NonVarId '(' ListVarId ')' ':' VarTupleList { AbsPavingVars.VarTupleListBindN $1 $3 $6 }
                 | NonVarId ':' VarTupleList { AbsPavingVars.VarTupleListBind0 $1 $3 }
ListVarTupleListBind :: { [VarTupleListBind] }
ListVarTupleListBind : VarTupleListBind { (:[]) $1 }
                     | VarTupleListBind ListVarTupleListBind { (:) $1 $2 }
VarTupleListProg :: { VarTupleListProg }
VarTupleListProg : ListVarTupleListBind { AbsPavingVars.VarTupleListProg $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

