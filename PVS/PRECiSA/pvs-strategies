;;
;; The strategies defined in this file are intended to be used to automatically prove
;; the certificates generated by PRECiSA.
;;

;;
;; BEGIN Strategies for symbolic lemmas
;;
(defstep precisa ()
  (then
   (skeep)
   (let ((fnums (get-round-off-bound-fnums)))
     (if fnums
	 (then
	  (cleanup-precisa-certificate)
	  (let ((prove-steps (loop for fnum in fnums
				  collect `(prove-symbolic-error-bound-on$ ,fnum))))
	   (try-here$ prove-steps)))
       (skip-msg "Error: no formula stating a bound on round-off error was found."))))
  "[PRECiSA] Prove symbolic lemmas generated by PRECiSA."
  "Trying to prove PRECiSA certificate")

(defhelper cleanup-precisa-certificate ()
  (then 
   ;; simplify div_safe with ground divisors
   (repeat* (match "div_safe(%1,%2)" step (let ((divisor (args2(ee-pvs-obj $1)))) (if (ground-expr? divisor) (then (lemma "div_safe") (replace -1 :hide? t) (beta) (let ((guard "%2 = 0")) (eval-expr guard)) (replace -1 :hide? t)) (skip)))))
   ;; precisa outputs "0/1"
   (eval-expr "0/1")
   (try
    (replace -1 :hide? t)
    (skip)
    (hide -1))
   )
  ""
  "")

(defhelper prove-symbolic-error-bound-on (fnum)
  (let ((debug #+stratdebug (format t "~%[prove-symbolic-error-bound-on fnum ~a]~%" fnum)))
    (then
     (expand-usrdef-fp-fun$ fnum)
     (if (let*((loc  (list '!! fnum 2))
	       (form (extra-get-expr loc)))
	   (and (application? form)
		(eq 'max (id (operator form)))))
	 (precisa--ifthenelse-case fnum)
       (precisa--not-ifthenelse-case fnum))))
  "[PRECiSA] Try to prove the symbolic error bound expressed in formula number FNUM."
  "Proving symbolic error bound expression.")

(defparameter *precisa-builtin*
  '(;; Single floating-point operations require PRECiSA@bbiasp.PrecisaSP__
    ("*expand*" ("interval_ulp_sp.ULP_SP"
		 "bbiasp_add.AEB_ADD"
		 "bbiasp_sub.AEB_SUB"
		 "bbiasp_mul.AEB_MUL"
		 "bbiasp_div.AEB_DIV"
		 "bbiasp_flr.AEB_FLR"
		 "bbiasp_flr_t.AEB_FLR_T"
		 "bbiasp_sqt.AEB_SQT"
		 "bbiasp_exp.AEB_EXP"
		 "bbiasp_ln.AEB_LN"
		 "bbiasp_sin.AEB_SIN"
		 "bbiasp_cos.AEB_COS"
		 "bbiasp_atn.AEB_ATN"
		 "bbiasp_atn_t.AEB_ATN_T"
		 "bbiasp_neg.AEB_NEG"
		 "interval_ulp_dp.ULP_DP"
		 "bbiadp_add.AEB_ADD"
		 "bbiadp_sub.AEB_SUB"
		 "bbiadp_mul.AEB_MUL"
		 "bbiadp_div.AEB_DIV"
		 "bbiadp_flr.AEB_FLR"
		 "bbiadp_flr_t.AEB_FLR_T"
		 "bbiadp_sqt.AEB_SQT"
		 "bbiadp_exp.AEB_EXP"
		 "bbiadp_ln.AEB_LN"
		 "bbiadp_sin.AEB_SIN"
		 "bbiadp_cos.AEB_COS"
		 "bbiadp_atn.AEB_ATN"
		 "bbiadp_atn_t.AEB_ATN_T"
		 "bbiadp_neg.AEB_NEG"
		 "bbiadp_mul.AEB_MUL_P2L"
		 "bbiadp_mul.AEB_MUL_P2R" ))
    ("div_safe" "IntervalExpr_adt.DIV")
    ("ulp_sp" "interval_ulp_sp.ULP_SP" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_add" "bbiasp_add.AEB_ADD" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_sub" "bbiasp_sub.AEB_SUB" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_mul" "bbiasp_mul.AEB_MUL" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_div" "bbiasp_div.AEB_DIV" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_flr" "bbiasp_flr.AEB_FLR" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_flr_t" "bbiasp_flr_t.AEB_FLR_T" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_sqt" "bbiasp_sqt.AEB_SQT" "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_sin" ("bbiasp_sin.AEB_SIN") "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_exp" ("bbiasp_exp.AEB_EXP") "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_ln"  ("bbiasp_ln.AEB_LN")  "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_cos" ("bbiasp_cos.AEB_COS") "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_atn" ("bbiasp_atn.AEB_ATN") "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_atn_t" ("bbiasp_atn_t.AEB_ATN_T") "PRECiSA@bbiasp.PrecisaSP__")
    ("aeboundsp_neg" "bbiasp_neg.AEB_NEG" "PRECiSA@bbiasp.PrecisaSP__")
    ;; Double floating-point operations require PRECiSA@bbiadp.PrecisaDP__
    ("ulp_dp" "interval_ulp_dp.ULP_DP" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_add" "bbiadp_add.AEB_ADD" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_sub" "bbiadp_sub.AEB_SUB" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_mul" "bbiadp_mul.AEB_MUL" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_div" "bbiadp_div.AEB_DIV" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_flr" "bbiadp_flr.AEB_FLR" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_flr_t" "bbiadp_flr_t.AEB_FLR_T" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_sqt" "bbiadp_sqt.AEB_SQT" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_sin" ("bbiadp_sin.AEB_SIN") "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_cos" ("bbiadp_cos.AEB_COS") "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_atn" ("bbiadp_atn.AEB_ATN") "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_atn_t" ("bbiadp_atn_t.AEB_ATN_T") "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_exp" ("bbiadp_exp.AEB_EXP") "PRECiSA@bbiasp.PrecisaSP__")
    ("aebounddp_ln"  ("bbiadp_ln.AEB_LN")  "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_neg" "bbiadp_neg.AEB_NEG" "PRECiSA@bbiadp.PrecisaDP__")
    ("aebounddp_mul_p2l"
     ("bbiadp_mul.AEB_MUL_P2L"
      (lambda (args translator)
	(format nil
		"bbiadp_mul.AEB_MUL_P2L(~a)(~a)"
		(let ((first-arg (car args)))
		  ;; the first arg has to be a number-expr (a natural)
		  (if (number-expr? first-arg)
		      (number first-arg)
		    (ia-error "Error translating PVS arithmetic expression to IntervalArith: the first argument of aebounddp_mul_p2l is not a number-expr.")))
		(let ((snd-arg (if (eq (length (cdr args)) 1)
				   (cadr args)
				 (ia-error "Error translating PVS arithmetic expression to IntervalArith: aebounddp_mul_p2l does not have two arguments, as expected."))))
		  (funcall translator snd-arg)))))
     "PRECiSA@bbiadp.PrecisaDP__")

    ("aebounddp_mul_p2r"
     ("bbiadp_mul.AEB_MUL_P2R"
      (lambda (args translator)
	(format nil
		"bbiadp_mul.AEB_MUL_P2R(~a)(~a)"
		(let ((first-arg (car args)))
		  ;; the first arg has to be a number-expr (a natural)
		  (if (number-expr? first-arg)
		      (number first-arg)
		    (ia-error "Error translating PVS arithmetic expression to IntervalArith: the first argument of aebounddp_mul_p2r is not a number-expr.")))
		(let ((snd-arg (if (eq (length (cdr args)) 1)
				   (cadr args)
				 (ia-error "Error translating PVS arithmetic expression to IntervalArith: aebounddp_mul_p2r does not have two arguments, as expected."))))
		  (funcall translator snd-arg)))))
     "PRECiSA@bbiadp.PrecisaDP__")))

(defstep precisa-interval (&optional 
		   (fnums 1) (precision 3) maxdepth sat?
		   vars 
		   dirvar
		   verbose?
		   label
		   (equiv? t)
		   (tccs? t))
  (let ((subs *precisa-builtin*))
    (interval$ :fnums fnums :precision precision :maxdepth maxdepth
	      :sat? sat? :vars vars :subs subs :dirvar dirvar
	      :verbose? verbose? :label label :equiv? equiv? :tccs? tccs?))
  "" "[PRECiSA] Interval strategy for PRECiSA"
  )

(defstrat precisa-numerical (expr
			     &optional 
			     (precision 3)
			     (maxdepth 10)
			     min?
			     max?
			     vars
			     dirvar
			     verbose?
			     label
			     (equiv? t))
  (let ((subs *precisa-builtin*))
    (numerical expr :precision precision :maxdepth maxdepth
	      :max? max? :min? min :vars vars :subs subs :dirvar dirvar
	      :verbose? verbose? :label label :equiv? equiv?))
  "[PRECiSA] Numerical strategy for PRECiSA")

(defstrat assert-condition (fnum)
  (try (then 
	(disjunctive-hypothesis (fnum))
	(rewrite "neq_rew")
	(rewrite "noteq_rew")
	(eval-formula* :quiet? t)
	(branch (grind-reals) ((fail)))
	(fail))
       (skip)
       (subtype-tcc))
  "[PRECiSA] Try to prove the hypothesis of the main lemma."
  "Proving hypothesis...")

(defstep disjunctive-hypothesis (fnum)
  (then
   (let ((current-target-locator (list '!! fnum)))
     (unname-this current-target-locator))
   (let ((modified-formula-locators (loop for fnum in (get-new-formula-fnums) collect (list '!! fnum))))
     (unname-these modified-formula-locators))
   (branch
    (prop)
    ((assert))))
  "[PRECiSA] Try to close a hypothesis branch, using disjunctive premises."
  "Proving hypothesis of the main lemma using disjunctive premises...")

;; General purpose strategies.

(defstep try-here (steplists &optional (closing? t))
  (let ((steplists (if (listp steplists) steplists (list steplists)))
	(try-steps (reduce (lambda (sl1 sl2) `(try (try ,sl1 ,(if closing? '(fail) '(skip)) (skip))
						   (skip) ,sl2))
			   steplists
			   :initial-value `(skip)
			   :from-end t)))
    (then try-steps))
  "[PRECiSA] When CLOSING? is T (default), each of the steps given in STEPLISTS is tried on the current sequent until the branch is closed (CLOSING? is not nil) or the application of a step modifies the sequent (CLOSING? is nil) or the there are no more steps to try."
  "Applying the steps: ~%~{  ~a~%~}")

(defstrat branch-lemmas (lemma-names next-step)
  (let ((lsteps (loop for lname in lemma-names
		      collect `(then (lemma ,lname) ,next-step))))
    (try-here$ lsteps :closing? nil))
  "[PRECiSA] Try to introduce each of the lemmas in LEMMA-NAMES in order, and then apply the step in NEXT_STEP."
  "Applying lemmas: ~%~{~a~%~}")

(defstep connect-ineqs__ (fnum1 fnum2 &optional (precision 3) maxdepth)
  (with-fresh-labels ((l1 fnum1) (l2 fnum2))
   (spread
   (with-tccs (invoke (case "%1 <= %2") (! l1 2) (! l2 2)))
   ((then
     (with-fresh-names ((freshname (! l1 1))) (assert))
	;; if the replace didn't close the branch, then is useless to try to 
	;; close the rest of the branches.
     (fail))
    (then
     (let ((forms (loop for fnum in (map-fnums-arg *)
			when (let ((form (manip-get-formula fnum)))
			       (and (infix-application? form)
				    (eq (id (operator form)) '|##|)))
			collect fnum)) (forms (cons 1 forms)))
       (hide-all-but forms))
     #+stratdebug (let ((debug (break " [connect-ineqs__ fnum1 ~a fnum2 ~a] Stopping ~%" fnum1 fnum2))) (skip))
     (precisa-interval :precision precision :maxdepth maxdepth)
     (expand "div_safe")))))
  "[PRECiSA] Try to close a branch introducing an explicit link in the transitivity of an inequality."
  "Closing branch using transitivity of <=.")

;; Concrete certificates

(defstep prove-concrete-lemma (symb-bound-lemma-name &optional (precision 3) maxdepth)
  (branch
   (case "integer_pred(0)")
   ((then
     (skeep)
     (lemma symb-bound-lemma-name)
     (instantiate-symbolic-lemma -1)
     (branch (split -1)
	     ((complete-trans$ precision maxdepth)
	      (try (assert) (complete-trans) (fail)))))
    (assert)))
  "[PRECiSA] Strategy to prove concrete certificates generated by PRECiSA."
  "Trying to prove concrete certificate...")

(defun is-double-precision-expr? (expr)
  (if (and (application? expr) )))

(defhelper instantiate-symbolic-lemma (lemma-fnum)
  (let ((symb-lemma-bindings (bindings(manip-get-formula lemma-fnum)))
	(is-double-precision-lemma? (some (lambda (bind)
					    (eq (id(print-type(type bind))) 'double))
					  symb-lemma-bindings))
	(bindings (loop for bind in symb-lemma-bindings
			collect (let ((var-name (string (id bind))))
				  (if (string-prefix? "e_" var-name)
				      (if is-double-precision-lemma?
					  (format nil "ulp_dp(r_~a)/2" (subseq var-name 2))
					(format nil "ulp_sp(r_~a)/2" (subseq var-name 2)))
				    var-name)))))
    (instantiate lemma-fnum bindings))
  "[PRECiSA] Instantiate symbolic lemma generated by PRECiSA."
  "Instantiating symbolic lemma...")

(defhelper apply-for-each (name exprs steps)
  (let((exprs (cond  ((symbolp exprs) (symbol-value exprs))
		     ((listp exprs) exprs)
		     (t (list exprs)))))
    (if (and exprs (listp exprs))
      (let ((run-me `(let ((,name (quote ,(car exprs))))
		       ,steps))
	    (clos-tail (cdr exprs)))
	(then run-me (apply-for-each$ name clos-tail steps)))
      (skip)))
  "Apply the provided STEPS once for each expression in EXPRS binding them to NAME."
  "Applying steps...")

(defstep evaluate-ground-bound-expressions (&optional (fnums '*))
  (let ((candidate-exprs
	 (loop for fnum in (get-relations fnums '(<=))
	       for form = (extra-get-expr fnum)
	       append (and (roundoff-error-bound? form) 
			   (let ((bound-expr (args2 form)))
			     (when (and (not (number-expr? bound-expr)) (ground-expr? bound-expr))
			       (list (format nil "~a" bound-expr))))))))
    (if candidate-exprs
	(apply-for-each$ name candidate-exprs (then (eval-expr name) (replace -1 * :hide? t)))
      (skip-msg "No ground bound exprs found")))
  "Evaluate all ground subexpressions in FNUMS"
  "Evaluating subexpression in formulas: ~a")

(defstep complete-trans (&optional (precision 3) maxdepth)
  (let ((bla-name (freshname "bla")))
    (then
     (expand* ">" ">=")
     ;; first, try evaluating nonliteral ground bound expressions, e.g., max(0,0)
     (evaluate-ground-bound-expressions)
     ;; the disjunctive formulas are not needed in the rest of the proof
     ;; of this branch. Then, they are hidden.
     (let ((or-forms (loop for fnum in (map-fnums-arg *)
			   when (or+form? (manip-get-formula fnum))
			   collect fnum)))
       (hide or-forms))
     (branch
      (prop)
      ((let ((neg-ineqs (get-relations '- '(<=)))
	     (pos-ineqs (get-relations '+ '(<=)))
	     (asserts_leq (loop for nfnum in neg-ineqs
				append (loop for pfnum in pos-ineqs
					     collect `(connect-ineqs__$
						       ,nfnum
						       ,pfnum
						       ,precision
						       ,maxdepth))))
	     (neg-ineqs (get-relations '- '(<)))
	     (pos-ineqs (get-relations '+ '(<)))
	     (asserts_lt  (loop for nfnum in neg-ineqs
				append (loop for pfnum in pos-ineqs
					     collect `(connect-ineqs__$
						       ,nfnum
						       ,pfnum
						       ,precision
						       ,maxdepth)))))
	 (then
	  (try-here$ asserts_leq)
	  (try-here$ asserts_lt)))))))
  "[PRECiSA] Specific-purpouse strategy. Intended to close the main branch of proofs about floating point accumulated error calculation."
  "Closing main branch...")

;; TCCs from symbolic certificates

(defstrat precisa-gen-cert-tcc ()
  (try (then (skeep) (eval-formula* :quiet? t) (fail))
       (skip)
       (try (then (grind-reals) (fail))
		   (skip)
		   (subtype-tcc)))
  "[PRECiSA] Strategy to prove tccs from PRECiSA generated symbolic certificates."
  "Proving PRECiSA tcc...")

;; Checks whether the formula fnum has form abs(CONVERSION(expr_F) - expr_R) <= error
;; If so, returns (list expr_F expr_R)
(defun precisa-get-subjects (fnum)
  (let*((formula (extra-get-expr fnum))
	(rel (is-order-relation formula)))
    (when (and rel (equal rel '<=))
      (list (extra-get-expr `(! ,fnum 1 1 1 1)) (extra-get-expr `(! ,fnum 1 1 2))))))

(defconstant *precisa-error-fun-lemma-mapping*
  (let*((result nil)
	;; single-precision error expressions
        (result (acons 'aeboundsp_mul     "Smul_aerr"      result))
        (result (acons 'aeboundsp_add     "Sadd_aerr"      result))
        (result (acons 'aeboundsp_sub     "Ssub_aerr"      result))
        (result (acons 'aeboundsp_abs     "Sabs_aerr"      result))
        (result (acons 'aeboundsp_atn     "Satan_aerr"     result))
        (result (acons 'aeboundsp_atn_t   "Satan_t_aerr"   result))
        (result (acons 'aeboundsp_cos     "Scos_aerr"      result))
        (result (acons 'aeboundsp_div     "Sdiv_aerr"      result))
        (result (acons 'aeboundsp_flr     "Sfloor_aerr"    result))
        (result (acons 'aeboundsp_flr_t   "Sfloor_t_aerr"  result))
        (result (acons 'aeboundsp_mul_p2l "Smulpow2l_aerr" result))
        (result (acons 'aeboundsp_mul_p2r "Smulpow2r_aerr" result))
        (result (acons 'aeboundsp_neg     "Sneg_aerr"      result))
        (result (acons 'aeboundsp_sin     "Ssin_aerr"      result))
        (result (acons 'aeboundsp_sqt     "Ssqrt_aerr"     result))
        (result (acons 'aeboundsp_exp     "Sexp_aerr"      result))
        (result (acons 'aeboundsp_ln      "Sln_aerr"       result))
	;; double-precision error expressions
        (result (acons 'aebounddp_mul     "Dmul_aerr"      result))
        (result (acons 'aebounddp_add     "Dadd_aerr"      result))
        (result (acons 'aebounddp_sub     "Dsub_aerr"      result))
        (result (acons 'aebounddp_abs     "Dabs_aerr"      result))
        (result (acons 'aebounddp_atn     "Datan_aerr"     result))
        (result (acons 'aebounddp_atn_t   "Datan_t_aerr"   result))
        (result (acons 'aebounddp_cos     "Dcos_aerr"      result))
        (result (acons 'aebounddp_div     "Ddiv_aerr"      result))
        (result (acons 'aebounddp_flr     "Dfloor_aerr"    result))
        (result (acons 'aebounddp_flr_t   "Dfloor_t_aerr"  result))
        (result (acons 'aebounddp_mul_p2l "Dmulpow2l_aerr" result))
        (result (acons 'aebounddp_mul_p2r "Dmulpow2r_aerr" result))
        (result (acons 'aebounddp_neg     "Dneg_aerr"      result))
        (result (acons 'aebounddp_sin     "Dsin_aerr"      result))
        (result (acons 'aebounddp_sqt     "Dsqrt_aerr"     result))
        (result (acons 'aebounddp_exp     "Dexp_aerr"      result))
        (result (acons 'aebounddp_ln      "Dln_aerr"       result)))
    result))

(defconstant *precisa-builtin-fp-ops*
  (let*((result nil)
	;; single-precision operations
        (result (cons 'Smul   result))
        (result (cons 'Sadd   result))
        (result (cons 'Ssub   result))
        (result (cons 'Sabs   result))
        (result (cons 'Satan  result))
        (result (cons 'Scos   result))
        (result (cons 'Sdiv   result))
        (result (cons 'Sfloor result))
        (result (cons 'Smul   result))
        (result (cons 'Sneg   result))
        (result (cons 'Ssin   result))
        (result (cons 'Ssqrt  result))
        (result (cons 'Sexp   result))
        (result (cons 'Sln    result))
	;; single-precision operations
        (result (cons 'Dmul   result))
        (result (cons 'Dadd   result))
        (result (cons 'Dsub   result))
        (result (cons 'Dabs   result))
        (result (cons 'Datan  result))
        (result (cons 'Dcos   result))
        (result (cons 'Ddiv   result))
        (result (cons 'Dfloor result))
        (result (cons 'Dmul   result))
        (result (cons 'Dneg   result))
        (result (cons 'Dsin   result))
        (result (cons 'Dexp   result))
        (result (cons 'Dln    result))
        (result (cons 'Dsqrt  result)))
    result))

(defun collect-userdef-fun-lemmas (userdef-fun-name)
  (let((prefix-target (format nil "~a_" userdef-fun-name)))
    (loop for decl in (all-declarations(theory (context *ps*)))
	  when (and (formula-decl? decl)
		    (let ((decl-name (string(id decl))))
		      (and (not (search "TCC" decl-name))
			   (let((pos(search prefix-target decl-name)))
			     (and pos (eq 0 pos))))))
	  collect (string(id decl)))))

(defun precisa-get-lemma-name--error-expr (fnum)
  (let ((formula (extra-get-expr fnum)))
    (let* ((form-info  (roundoff-error-bound? formula))
	   (fp-symb    (when (<= 1 (length form-info)) (first  form-info)))
	   (r-symb     (when (<= 2 (length form-info)) (second form-info)))
	   (error-symb (when (<= 3 (length form-info)) (third  form-info)))) 
      (if (member fp-symb *precisa-builtin-fp-ops*)
	  (let ((error-symb--lemma-name
		 (assoc error-symb *precisa-error-fun-lemma-mapping* :test #'equal)))
	    (when error-symb--lemma-name
	      (list (cdr error-symb--lemma-name))))
	(collect-userdef-fun-lemmas (format nil "~a" fp-symb))))))

;;
;; BEGIN Error bounds recognizers.
;;

(defun roundoff-error-bound? (formula &optional admit-literal?)
  "Checks if the given formula has form abs(CONVERSION(f_FP(...)) - f_R(...)) <= error_expr."
  (let((rel (is-order-relation formula)))
    (when 
	(let((abs-fp-minus-real-expr (args1 formula)))
	  (and rel
	       (eq rel '<=)
	       (eq 'abs (id(operator abs-fp-minus-real-expr)))
	       (eq '- (id(operator(args1 abs-fp-minus-real-expr))))
	       (let*((sub-arg1 (args1(args1 abs-fp-minus-real-expr)))
		     (sub-arg1-oper (id(operator sub-arg1))))
		 (or
		  (and (eq 'DtoR sub-arg1-oper)
		       ;; the next condition avoids the case of a real constant.
		       (or admit-literal?
			   (let ((fpexpr (args1 sub-arg1)))
			     (or (and (application? fpexpr)
				      (not (eq 'RtoD (id(operator fpexpr)))))
				 (name-expr? fpexpr)))))
		  (and (eq 'StoR sub-arg1-oper)
		       ;; the next condition avoids the case of a real constant.
		       (or admit-literal?
			   (let ((fpexpr (args1 sub-arg1)))
			     (or (and (application? fpexpr)
				      (not (eq 'RtoS (id(operator fpexpr)))))
				 (name-expr? fpexpr)))))))
	       (let ((rexpr (args2(args1 abs-fp-minus-real-expr))))
		 (or (and admit-literal? (ground-expr? rexpr))
		     (application? rexpr)
		     (name-expr? rexpr)))
	       (or (application? (args2 formula))
		   (name-expr? (args2 formula)))))
      (list 
       (let ((fp-expr   (args1(args1(args1(args1 formula))))))
	 (cond
	  ((let-expr? fp-expr)
	   (id(operator(expression (operator fp-expr)))))
	  ((application? fp-expr)
	   (id(operator(args1(args1(args1(args1 formula)))))))
	  (t fp-expr)))
       (let((rexpr (args2(args1(args1 formula)))))
	 (if (application? rexpr)
	     (id(operator rexpr))
	   (and admit-literal? (ground-expr? rexpr))))
       (let ((error-bound-expr (args2 formula)))
	 (if (application? error-bound-expr)
	     (id(operator error-bound-expr))
	   nil))))))

;; Error bounds that refer to more than one possible control flow of the original
;; program are called condensed error bounds. This kind of error bound is easily
;; recognizable since their error expression is an application of the max operator.
(defun is-condensed-error-bound? (formula)
  "Tests if the given formula is a condensed error bound."
  (let ((err-bound (roundoff-error-bound? formula t)))
    (and err-bound
	 (eq 'max (third err-bound)))))

(defun get-condensed-error-bound-fnums ()
  "Returns the fnums where condensed error bounds are present, if any."
  (gather-fnums
   (s-forms (current-goal *ps*))
   '+
   nil
   #'(lambda (x)
       (is-condensed-error-bound? (formula x)))))

(defun get-round-off-bound-fnums (&optional admit-literals?)
  (gather-fnums
   (s-forms (current-goal *ps*))
   '+
   nil
   #'(lambda (sequent-formula)
       (roundoff-error-bound? (formula sequent-formula) admit-literals?))))

(defun get-condensed-error-bound-fnums ()
  (gather-fnums
   (s-forms (current-goal *ps*))
   '+
   nil
   #'(lambda (sequent-formula)
       (is-condensed-error-bound? (formula sequent-formula)))))


;; checks whether the formula fnum has form abs(CONVERSION(expr_F) - expr_R) <= error_expr
;; If so, returns "error_expr"
(defun precisa-get-error-expr (fnum)
  (let*((formula (extra-get-expr fnum))
	(rel (is-order-relation formula)))
    (when (and rel (equal rel '<=))
      (extra-get-expr `(! ,fnum 2)))))

;;
;; END Error bounds recognizers.
;;

(defmacro fp-arg-in-precisa-bound-formula (formula)
  `(args1(args1(args1(args1 ,formula)))))

(defun precisa-unifier (open-expr closed-expr)
  "It returns a list (var expr var expr ...)"
  (cond
   ((name-expr? open-expr)
    (list (format nil "~a" open-expr)
	  (format nil "~a" closed-expr)))
   ((and (application? open-expr)
	 (application? closed-expr)
	 (= (length (arguments open-expr)) (length (arguments closed-expr))))
    (loop for open-subexpr in (arguments open-expr)
	  for closed-subexpr in (arguments closed-expr)
	  append (precisa-unifier open-subexpr closed-subexpr)))
   (t (error
       (format nil
	       "[precisa-unifier] open ('~a') and closed ('~a') expressions are not structurally similar."
	       open-expr closed-expr)))))

(defun subst-for-precisa-lemma (lemma-label target-label)
  (let ((target-form (extra-get-expr (list '!! (intern target-label))))
	(lemma-form  (args2 (expression(extra-get-expr (list '!! (intern lemma-label)))))))
    (loop for x on (precisa-unifier lemma-form target-form)
	  by #'cddr
	  unless (member-if #'(lambda (elem) (string= (car x) elem)) (cdr x))
	  append (list (car x) (cadr x)))))

(defstep instantiate-symbolic-error-lemma (lemma-label target-label ) ;;(&optional fp-arg))
  (let ((target-form (extra-get-expr (list '!! (intern target-label))))
	(id-op (id (operator (args2 target-form)))))
    (if (or (eq 'aeboundsp_mul_p2l id-op)
	    (eq 'aeboundsp_mul_p2r id-op)
	    (eq 'aebounddp_mul_p2l id-op)
	    (eq 'aebounddp_mul_p2r id-op))
	(let ((power-of-two-locator (if (or (eq 'aeboundsp_mul_p2l id-op)
					    (eq 'aebounddp_mul_p2l id-op))
					1
				      2)))
	  (then
	   (let ((loc (list '!! (intern target-label) 1 1 1 1 1 1)))
	     (unname-this loc))
	   (let ((loc (list '!! (intern target-label) 1 1 2 power-of-two-locator)))
	     (unname-this loc))
	   (let ((n (number (args1 (args2 target-form))))
		 (expr (extra-get-expr
			(list '!! (intern target-label) 1 1 1 1 power-of-two-locator 1)))
		 (expr2 (extra-get-expr (list '!! (intern target-label) 1 1 1 1 1 1)))
		 (case-str (format nil "~a=2^~a" expr n)))
	     (branch
	      (case case-str)
	      ((then
		(replace -1 target-label :hide? t)
		(inst? lemma-label :where target-label))
	       (eval-formula))))))
      (inst? lemma-label :where target-label)))
  "[PRECiSA] Tries to instantiate an accumulated error lemma, knowing that the referred formulas have a specific form."
  "")

(defhelper expand-auxiliar-names (fnum)
  ;; This construct assumes that formula in fnum has the form abs(DtoR(...) - (...)) <= ...
  (let ((f-expr (extra-get-expr (list '!! fnum 1 1 1 1)))
	(real-expr-locator (list '!! fnum 1 1 2))
	(r-expr (extra-get-expr real-expr-locator))
	(error-locator (list '!! fnum 2))
	(e-expr (extra-get-expr error-locator)))
    (then
     (if (name-expr? f-expr)
	 (expand f-expr :assert? none)
       (skip))
     (if (name-expr? r-expr)
	 (then
	  (expand r-expr :assert? none))
       (skip))
     (expand-and-simplify-safe-real-ops real-expr-locator)
     (if (name-expr? e-expr)
	 (expand e-expr :assert? none)
       (let ((debug #+stratdebug (format t "~%[expand-auiliar-names fnum ~a] not name-expr? e-expr~%" fnum)))
	 (skip))))
    ;; if the main symbol of the expanded expression is a _safe
    ;; operation, we need to get the unsafe version of the operator
    ;; instead, since unsafe operators is what we expect in the
    ;; left hand side of the error-bound expression.
    (expand-and-simplify-safe-real-ops error-locator))
  ""
  "")

(defun matches-with (expr pattern)
  (or (name-expr? pattern)
      (and (application? pattern)
	   (application? expr)
	   (eq (id(operator pattern)) (id(operator expr)))
	   (eq (length (arguments pattern)) (length (arguments expr)))
	   (loop for pat in (arguments pattern)
		 for exp in (arguments expr)
		 always (matches-with exp pat)))))

(defhelper precisa-rec (&optional (fnum 1) recursion-depth-limit)
  ;; This helper assumes that the formula in fnum has the following structure
  ;;
  ;;   abs(PROJECTION(FP_EXPR) - REAL_EXPR) <= REAL_EXPR
  ;;
  ;;
  (then
   #+stratdebug (let ((msg (format nil "~%[precisa-rec fnum ~a recursion-depth-limit ~a]~%" fnum recursion-depth-limit)))
		   (comment msg))
  (let((debug #+stratdebug (format t "~%[precisa-rec fnum ~a recursion-depth-limit ~a]~%" fnum recursion-depth-limit))
       (formula (extra-get-expr fnum)))
    (if (roundoff-error-bound? formula t)
        (then
	 (let ((error-expr-locator (list '!! fnum 2)))
	   (then
	    (unname-this error-expr-locator (max abs +))
	    (expand-and-simplify-safe-real-ops error-expr-locator)))
	 (let ((error-bound-expr (args2 formula)))
	  (if (error-bound-from-unstable-flow? error-bound-expr)
	      (precisa-rec-for-unstable-flow fnum recursion-depth-limit)
	    (precisa-rec-for-stable-flow fnum recursion-depth-limit))))
      (let ((loc (list '!! fnum)))
	(then
	 (let ((debug #+stratdebug (format t "~%[precisa-rec fnum ~a] NO error-bound form~%" fnum)))(skip)) ;; debug
	 (unname-this loc)
	 (try-here$
	  ((assert)
	   (eval-formula fnum :quiet? t)
	   (assert-condition fnum))))))))
  ""
  "")

(defmacro error-bound-from-unstable-flow? (error-bound-expr)
  ;; ERROR-BOUND-EXPR must be an expression from an error-bound formula with structure
  ;;
  ;;   abs(DtoR(FP_EXPR) - REAL_EXPR) <= ERROR-BOUND-EXPR
  ;;
  ;; The formulas of this kind describe round-off errors from unstable flows,
  ;; when the top-most operator is +.
  `(and
    (application? ,error-bound-expr)
    (eq '+ (id (operator ,error-bound-expr)))))

(defstrat precisa-rec-for-unstable-flow (fnum steps)
  ;; This helper assumes that the formula in fnum has the following structure
  ;;
  ;;   abs(PROJECTION(FP_EXPR) - REAL_EXPR) <= (NAME_EXPR1 + NAME_EXPR2)
  ;;
  ;; Where, NAME_EXPR2 can be expanded to abs(REAL_EXPR1 - REAL_EXPR2)
  (then
   (let ((name (extra-get-expr (list '!! fnum 2 2))))
     (expand name :assert? none))
   ;; expand the argument of absolute value
   (let ((abs-arg (extra-get-expr (list '!! fnum 2 2 1))))
     (expand abs-arg :assert? none))
   ;; expand the expression that corresponds to the result of the real-valued flow
   (let ((real-valued-flow-locator (list '!! fnum 2 2 1 2)))
     (then
      (unname-this real-valued-flow-locator)
      (expand-and-simplify-safe-real-ops real-valued-flow-locator)))
   (branch
    (case "FORALL(fx,rx,ry: real, ex: nonneg_real):
                abs(fx-rx) <= ex IMPLIES abs(fx - ry) <= ex + abs(rx-ry)")
    ((if (let ((pat (args2 (expression (extra-get-expr '(!! -1)))))
	       (expr (extra-get-expr (list '!! fnum))))
	   (matches-with expr pat))
	 (with-fresh-labels ((l fnum))
			    (inst? -1 :where l)
			    (branch
			     (split -1)
			     ((fail)
			      (then
			       (hide l)
			       (expand-auxiliar-names$ 1)
			       (let ((condensed-error-bound-fnums (get-condensed-error-bound-fnums)))
				 (if condensed-error-bound-fnums		 
				     (let ((one-of-them (car condensed-error-bound-fnums)))
				       (then
					(reduce-max*$ one-of-them t)))
				   (precisa-rec-again-unless-recursion-limit-reached fnum steps)))))))
       (then
	(then
	 (let((loc (list '!! fnum 1 1 1)))
	   (unname-this loc))
	 (let ((fx (extra-get-expr (list '!! fnum 1 1 1)))
	       (rx (pretty-print--float-to-real fx #'precisa-name-conversion))
	       (ex (extra-get-expr (list '!! fnum 2 1)))
	       (ry (extra-get-expr (list '!! fnum 1 1 2))))
	   (inst -1 fx rx ry ex)))
	(branch
	 (split -1)
	 ((then
	   (let ((locators (list (list '!! fnum) (list '!! 1))))
	     (unname-these locators))
	   (assert)
	   (fail))
	  (then
	   (unname-this (!! 1 2))
	   (precisa--not-ifthenelse-case 1 steps))))))
     (then
      (hide-all-but 1)
      (skeep)
      (lemma "abs_dist_other")
      (inst -1 "fx" "ry" "rx" "ex")
      (branch
       (split -1)
       ((then (expand "abs") (grind-reals))))))))
  ""
  "")

(defun precisa-name-conversion  (fp-name)
  (format nil "r_~a" fp-name))

(defun pretty-print--float-to-real (fp-expr &optional name-conversion)
  "Pretty prints a floating-point expression as a real-valued expression"
  (cond
   ((number-expr? fp-expr)
    (format nil "~a" fp-expr))
   ((name-expr? fp-expr)
    (if name-conversion
	(funcall name-conversion (format nil "~a" fp-expr))
      (format nil "~a" fp-expr)))
   ((application? fp-expr)
    (let ((op-id (id(operator fp-expr))))
      (cond
       ((or (eq 'DtoR op-id) (eq 'StoR op-id))
	(pretty-print--float-to-real (args1 fp-expr) name-conversion))
       ((or (eq 'RtoD op-id) (eq 'RtoS op-id))
	(pretty-print--float-to-real (args1 fp-expr) name-conversion))
       ((or (eq 'Dadd op-id) (eq 'Sadd op-id))
	(format nil "(~a + ~a)"
		(pretty-print--float-to-real (args1 fp-expr) name-conversion)
		 (pretty-print--float-to-real (args2 fp-expr) name-conversion)))
       ((or (eq 'Dsub op-id) (eq 'Ssub op-id))
	(format nil "(~a - ~a)"
		(pretty-print--float-to-real (args1 fp-expr) name-conversion)
		 (pretty-print--float-to-real (args2 fp-expr) name-conversion)))
       ((or (eq 'Dmul op-id) (eq 'Smul op-id))
	(format nil "(~a * ~a)"
		(pretty-print--float-to-real (args1 fp-expr) name-conversion)
		 (pretty-print--float-to-real (args2 fp-expr) name-conversion)))
	(t (error "Don't know how to pretty print application ~a." (show fp-expr))))))
   (t (error "Don't know how to pretty print ~a." (show fp-expr)))))

(defstrat precisa-rec-for-stable-flow (fnum steps)
  (let ((lemma-names (precisa-get-lemma-name--error-expr fnum)))
    (if lemma-names
	(branch-lemmas
	 lemma-names
	 (let ((lemma-label (freshname "l"))
	       (target-label (freshname "t")))
	   (then
	    (label lemma-label -1)
	    (label target-label fnum)
	    (with-tccs
	     (instantiate-symbolic-error-lemma$ lemma-label target-label))
	    (branch
	     (split -1)
	     (;; if the main branch is still open after the split,
	      ;; most probably the introduced lemma is not useful
	      ;; to close it. Backtrack, then.
	      (let (#+stratdebug
		    (debug
		     (break "[precisa-rec-for-stable-flow fnum ~a steps ~a]~
                             FAILING symbolic error lemma didn't closed the branched ~%"
			    fnum steps))) (fail)) 
	      (then
	       (hide target-label)
	       (let ((new-lemma-fnum (intern lemma-label))
		     (new-obligation (extra-get-expr new-lemma-fnum)))
		 (if (roundoff-error-bound? new-obligation t)
		     (then
		      (expand-auxiliar-names$ new-lemma-fnum)
		      (precisa-rec-again-unless-recursion-limit-reached fnum steps))
		   (then
		    (let ((new-obligation-locator (list '!! new-lemma-fnum))) (unname-this new-obligation-locator))
		    (eval-formula new-lemma-fnum)
		    (let (#+stratdebug
			  (debug
			   (break "[precisa-rec-for-stable-flow fnum ~a steps ~a]~
                             FAILING couldn't close non-roundoff-error branch ~%"
				  fnum steps))) (fail)))))))))))
      (then
       (assert)
       (skip-msg "The appropriate accumulated-error lemma can not be determined."))))
  "[PRECiSA] Proves error bounds in stable cases."
  "")

(defstrat precisa-rec-again-unless-recursion-limit-reached (fnum recursion-depth-limit)
  (if (numberp recursion-depth-limit)
      (if (< 1 recursion-depth-limit)
	  (let ((recursion-depth-limit (- recursion-depth-limit 1)))
	    (then
	     (precisa-rec$ :recursion-depth-limit recursion-depth-limit)))
	(skip))
    (then (precisa-rec$) (fail)))
  ""
  "")

(defhelper expand-usrdef-fp-fun (fnum)
  (let ((userdefsymb (roundoff-error-bound?(extra-get-expr fnum))))
    (if userdefsymb
	(let ((userdeffpstr (string (first userdefsymb)))
	      (userdefrealstr (string (second userdefsymb))))
	  (then
	   ;; In expressions such as IF alpha THEN RtoD(ct1) ELSE RtoD(ct2) ENDIF,
	   ;; expand (even with the flag assert? none) lifts the RtoD application
	   ;; to RtoD(IF alpha THEN ct1 ELSE ct2 ENDIF) which complicates the rest
	   ;; of the strategy. A more inocuous expansion can be obtained using
	   ;; rewrite+beta instead.
	   (rewrite userdeffpstr fnum)(beta fnum) 
	   ;; (rewrite userdefrealstr fnum)(beta fnum)
	   ;; Nevertheless, for definitions such as
	   ;; rlat_real(r_yz: real, r_j: real): real  = (6 * (r_j + (r_yz / 131072)))
	   ;; the rewrite+beta approach applies distributivity
	   ;; (6 * (r_yz / 131072) + 6 * r_j)
	   ;; Let's try with lemma+replace+beta
	   ;; (then (lemma userdeffpstr)(replace -1 fnum :hide? t)(beta fnum))
  	   (then (lemma userdefrealstr)(replace -1 fnum :hide? t)(beta fnum))))
      (skip)))
  "[PRECiSA] Tries to expand the user-defined function appearing in the round-off error formula in fnum"
  "Expanding user-defined functions")

(defhelper precisa-rewrite-powers-of-2 (fnum)
  (let ((powers (delete-duplicates (collect-power-2-fp-constants fnum) :from-end t))
	(powers (sort powers #'<))
	(steps (reduce (lambda (case-str next-step)
			 `(then
			   (spread
			    (case ,case-str)
			    ( (then (assert -1)
				    (hide -1)
				    ;; (replace -1 :hide? t)
				    )
			     (eval-formula)))
			   ,next-step))
		       (loop for n in powers
			     collect (format nil "~a=2^~a" (expt 2 n) n))
		       :initial-value `(skip)
		       :from-end t)))
    (then steps))
  "[PRECiSA] Rewrites powers of 2 to improve automatic instantiation of accumulated-error lemmas."
  "")

(defun collect-power-2-fp-constants (fnum)
  (let*((formula (extra-get-expr fnum)))
    (collect-power-2-fp-constants-rec formula)))

(defun collect-power-2-fp-constants-rec (expr)
  (cond
   ((application? expr)
    (let ((id-op (id(operator expr))))
      (cond
       ((or (eq 'aebounddp_mul_p2l id-op)
	    (eq 'aeboundsp_mul_p2l id-op))
	(let ((n (number (args1 expr))))
	  (list n)))
       ((or (eq 'aebounddp_mul_p2r id-op)
	    (eq 'aeboundsp_mul_p2r id-op))
	(let ((n (number (args2 expr))))
	  (list n)))
       (t (loop for arg in (arguments expr)
		append (collect-power-2-fp-constants-rec arg))))))
   (t nil)))

(defstep name-expressions (&rest exprs)
  (if exprs
      (let ((expr (car exprs)))
	(if (not (name-expr? expr))
	    (let ((args (arguments expr)))
	      (apply #'name-subexpressions args))))
    (skip))
  ""
  "")

(defstep name-this (manip-locator &optional (but nil))
  (let ((expr (extra-get-expr manip-locator))
	(debug #+stratdebug (format t "~&[name-this manip-locator ~a] (Entering) expr ~a~%" manip-locator expr)) ;; debug
	)
    (if (application? expr)
	(let ((op-id (id (operator expr))))
	  (if (and 
	       (not (eq '^ op-id)))
	      (let ((new-locators (if (mixfix-branch? expr)
				      ;; if the error-bound expression contains an IF-THEN-ELSE
				      ;; I only name the guard, since the expressions in the branches
				      ;; could generate TCCs.
				      (list (append manip-locator (list 1)))
				    (loop for i from 1 to (length (arguments expr))
					  collect (append manip-locator (list i))))))
		(then
		 (name-these$ new-locators but)
		 (if (or (mixfix-branch? expr)
			 (some #'(lambda (id)  (eq id op-id)) but))
		     (let ((debug #+stratdebug (format t "~&[name-this manip-locator ~a] omitting expr ~a for branch or but~%" manip-locator expr))) ;; debug
		       (skip))
		   (let ((expr (extra-get-expr manip-locator))
			 (name (freshname "fresh")))
		     (if (application? expr)
			 (branch
			  (let ((debug #+stratdebug (format t "~&[name-this manip-locator ~a] applying name ~a to ~a~%" manip-locator name expr)))
			    (name-replace name expr))
			  ;; the only branches I'm expecting here, are those generated as TCCs of the
			  ;; opeators. They should have a corresponding hypothesis to be proved trivially.
			  ;; The only exception is division by a literal. In that case, the resulting TCC
			  ;; looks like DtoR(RtoD(<literal>)) /= 0, which should be proved by applying
			  ;; eval-formula.
			  ((skip) (eval-formula 1)))
		       (let ((debug #+stratdebug (format t "~&[name-this manip-locator ~a] omitting (not app 1) ~
                                                            expr ~a~%" manip-locator expr))) ;; debug
			 (skip)))))))
	    (let ((debug #+stratdebug (format t "~&[name-this manip-locator ~a] omitting (not app 2) ~
                                                 expr ~a~%" manip-locator expr))) ;; debug
			 (skip))))
      (if (and (number-expr? expr) (= 0 (number expr))) ;; I keep the zeroes to avoid automatic simplifications
	  (let ((name (freshname "fresh"))
		(debug #+stratdebug (format t "~&[name-this manip-locator ~a] applying name ~a to ~a~%" manip-locator name expr)))
	    (name-replace name expr))
	(let ((debug #+stratdebug (format t "~&[name-this manip-locator ~a] omitting expr ~a~%" manip-locator expr))) ;; debug
	  (skip)))))
  ""
  "")
  
(defstep name-these (manip-locators &optional (but nil))
  (if manip-locators
      (let ((manip-locator (car manip-locators))
	    (rest-locators (cdr manip-locators)))
	(then
	 (name-this$ manip-locator but)
	 (name-these$ rest-locators but)))
    (skip))
  ""
  "")

(defmacro string-prefix? (prefix string)
  `(eq (string< ,prefix ,string) (length ,prefix)))

(defstep unname-this (manip-locator &optional (but nil))
  (then
   (let ((debug #+stratdebug (format t "~&[unname-this manip-locator ~a]~%" manip-locator));;debug
	 (expr (extra-get-expr manip-locator))
	 (debug #+stratdebug (format t "~&[unname-this manip-locator ~a] ~a~%" manip-locator expr));;debug
	 )
     (if (application? expr)
	 (if (not (member (id(operator expr)) but))
	     (let ((new-locators (loop for i from 1 to (length (arguments expr))
				       collect (append manip-locator (list i)))))
	       (then
		(unname-these$ new-locators but)))
	   (let ((debug #+stratdebug
			(format t "~&[unname-this manip-locator ~a] stopping on 'but' operator: ~a~%"
				manip-locator (id(operator expr)))))
	     (skip)))
       (if (field-application? expr)
	   (let ((loc (append manip-locator 1)))
	     (unname-this$ loc but))
	 (let((expr-name (format nil "~a" expr)))
	   (if (and (name-expr? expr)
		    (string-prefix? "fresh" expr-name))
	       (then
		(expand expr-name :assert? none)
		(let ((debug #+stratdebug (format t "~&[unname-this manip-locator ~a] calling itself~%" manip-locator))) ;;debug
		  (unname-this$ manip-locator but)))
	     (skip)))))))
  ""
  "")

(defstep unname-these (manip-locators &optional (but nil))
  (then
   (if manip-locators
       (let ((manip-locator (car manip-locators))
	     (rest-locators (cdr manip-locators)))
	 (then
	  (unname-this$ manip-locator but)
	  (unname-these$ rest-locators but)))
     (skip)))
  ""
  "")

(defun name-expressions (&rest exprs)
  (when exprs
    (let ((expr       (car exprs))
	  (more-exprs (cdr exprs)))
      (append
       (if (name-expr? expr)
	   (list (format nil "~a" expr))
	 (let ((opid      (id (operator expr)))
	       (arg-names (apply #'name-expressions (arguments expr))))
	   (cons (format nil "~a(~{~a~^,~})" opid arg-names) arg-names)))
       (apply #'name-expressions more-exprs)))))
       
(defstrat precisa--not-ifthenelse-case (fnum &optional steps)
  (let ((locators (list (list '!! fnum 1 1 1 1)
			(list '!! fnum 1 1 2)
			(list '!! fnum 2))))
    (then
     (name-these$ locators)
     (expand-auxiliar-names$ fnum)
     (precisa-rec$ fnum steps)))
  "[PRECiSA] Prove lemmas generated by PRECiSA."
  "Proving lemma...")

(defstrat precisa--ifthenelse-case (fnum &optional steps)
  (let ((locators (list (list '!! fnum 1 1 1 1)
			(list '!! fnum 1 1 2)
			(list '!! fnum 2))))
    (then
     #-stratdebug (name-these$ locators (max))
     #+stratdebug (name-these locators (max))
     (reduce-ifthenelse$ fnum)))
  "[PRECiSA] Prove lemmas generated by PRECiSA."
  "Proving lemma...")

(defmacro get-new-formula-fnums () '*new-fmla-nums*)

(defhelper simplify-if-then-else ()
  (let ((new-just-name-formulas
			    (loop for fnum in (get-new-formula-fnums)
				  when (name-expr? (extra-get-expr fnum))
				  collect (list '!! fnum))))
    (for-each
     ;; replace the guards and unname the expressions, since they
     ;; could be needed to prove TCCs from the error-bound expression
     (let ((loc (list '!! $1n))) (then (replace $1n) (unname-this loc)))
     new-just-name-formulas))
  ""
  "[PRECiSA] Tries to simplify error bound conditions containing if-then-else expressions.")

(defstep reduce-ifthenelse (fnum)
  (let ((split-on-us ;; formula numbers containing the mixed path conditions
	 (fnum-for-path-conditions fnum))
	(finishing-steps
	 (loop for split-fnum in split-on-us
	       collect
	       `(then 
		 (branch
		  (split ,split-fnum)
		  ( (then
		     (flatten)
		     (simplify-if-then-else)
		     (let (; these are the forms simplified by the last proof step,
			   ;; they should be the error bound forms containing
			   ;; if-then-else constructs. If there are more than one,
			   ;; the assert simplified additional formulas. That
			   ;; would be an erroneous case.
			   (simplified-forms
			    (loop for fnum in (get-new-formula-fnums)
				  when (is-condensed-error-bound? (extra-get-expr fnum))
				  collect fnum)))
		       (if (and simplified-forms
				(eq (length simplified-forms) 1))
			   (let ((fnum (car simplified-forms))
				 (max-expr-locator (list '!! fnum 2)))
			     (then
			      ;; if the max operation is applied on literals, it can
			      ;; be computed.
			      (when (let ((max-expr (extra-get-expr fnum)))
				      (ground-expr? max-expr))
				(eval-formula fnum))
			      (reduce-max*$ fnum)))
			 (let((msg "~%[reduce-ifthenelse] FAIL more than one formula was affected assuming the path conditions.~%")
			      (dummy
			       #+stratdebug
			       (break msg)
			       ;;(format t msg)
			       ))
			   (fail)))))))))))
    (try-here$ finishing-steps :closing? nil))
  ""
  "")

(defhelper reduce-max* (fnum &optional (try-to-close-the-proof t) )
  (let ((debug #+stratdebug (format t "~%[reduce-max* fnum ~a] ENTERING ~%" fnum))) ;; debug
    (then
     #+stratdebug (let ((msg(format t "~%[reduce-max* fnum ~a] ENTERING ~%" fnum))) (comment msg))
   (branch
    (case "FORALL(x,y,z:real): x<=y or x<=z IMPLIES x<=max(y,z)")
    ((with-fresh-labels
      ((l fnum))
      (inst? -1 :where l)
      (branch
       (split -1)
       ((let (#+stratdebug (debug (break "~%[reduce-max* fnum ~a] FAIL the lemma didn't close the branch.~%" fnum )))
	  (fail)) ; in case the lemma didn't close the branch
	(then (hide l)
	      (flatten)
	      ;; if some of the remaining targets is ground, it should be possible to close
	      ;; the proof branch by evaluating the formula.
	      (let ((ground-fnums
		     (gather-fnums (s-forms (current-goal *ps*))
				   (get-new-formula-fnums)
				   nil
				   #'(lambda (x) (ground-expr? (formula x))))))
		(eval-formula* ground-fnums))
	      
	      (let ((condensed-error-bound-fnums (get-condensed-error-bound-fnums))
		    (debug #+stratdebug (format t "~%[reduce-max* fnum ~a] condensed-error-bound-fnums ~a ~%" fnum condensed-error-bound-fnums)) ;; debug
		    )
		(if condensed-error-bound-fnums		 
		    (let ((one-of-them (car condensed-error-bound-fnums)))
		      (then
		       (reduce-max*$ one-of-them try-to-close-the-proof)))
		  (if try-to-close-the-proof
		      (let ((fnums (get-round-off-bound-fnums t))
			    (debug #+stratdebug
				   (unless fnums (break "~%[reduce-max* fnum ~a] ~
                                                         no fnums for try-precisa-rec-on-fnums call~%" fnum))))
			(try-precisa-rec-on-fnums$ fnums))
		    (skip))))))))
     ;; Proof for the lemma
     (then (hide-all-but 1) (skeep) (grind-reals))))))
  "[PRECiSA] "
  "")

(defun fnum-for-path-conditions (fnum)
  "Returns the fnum of the disjunction that expresses all the
   path of interest for this lemma."
  (let ((fp-guard (extra-get-expr (list '!! fnum 1 1 1 1 1)))
	(rl-guard (extra-get-expr (list '!! fnum 1 1 2 1))))
    (gather-fnums
     (s-forms (current-goal *ps*))
     '-
     nil
     #'(lambda (x)
	 (contains-some-of-these-names? (argument (formula x)) fp-guard rl-guard)))))

(defun contains-some-of-these-names? (expr name1 name2)
  (or (or (and (name-expr? expr) (string= (string (id name1)) (string (id expr))))
	  (and (name-expr? expr) (string= (string (id name2)) (string (id expr)))))
      (and (application? expr)
	   (some #'(lambda (expr) ( contains-some-of-these-names? expr name1 name2))
		  (arguments expr)))))

(defun all-subexpressions-are-names? (expr prefix)
  (or (and (name-expr? expr) (string<= prefix (string (id expr))))
      (and (application? expr)
	   (every #'(lambda (expr) (all-subexpressions-are-names? expr prefix))
		  (arguments expr)))))

(defhelper try-precisa-rec-on-fnums (fnums &optional steps)
  (let ((debug #+stratdebug (format t "~%[try-precisa-rec-on-fnums fnums ~a]~%" fnums)) ;; debug
	(lsteps (loop for fnum in fnums
		      when (> fnum 0)
		      collect `(then 
				(expand-auxiliar-names$ ,fnum) 
				(precisa-rec$ ,fnum ,steps)))))
    (if lsteps
	(try-here$ lsteps :closing? t)
      (skip-msg "No fnums provided")))
  ""
  "")

(defhelper expand-and-simplify-safe-real-ops (error-locator)
  (let ((e-expr (extra-get-expr error-locator)))
    (let((safe-ops (and (application? e-expr)
			(append
			 (when (string= (string (id (operator e-expr))) "div_safe")
			   (acons (string (id (operator e-expr))) (append error-locator (list 1)) nil))
			 (loop for arg in (arguments e-expr) 
			       for i from 1 to (length (arguments e-expr))
			       when (and (application? arg) (string= (string (id (operator arg))) "div_safe"))
			       collect `(,(string (id (operator arg))) . ,(append error-locator (list i 1))))))))
      (when safe-ops
	(apply-for-each 
	 safe-op 
	 safe-ops 
	 (let ((name (car safe-op))
	       (locator  (cdr safe-op)))
	   (then 
	    (expand name :assert? none)
	    (let ((guard (extra-get-expr locator))
		  (match-str (format nil "^~a$" guard)))
	      (match match-str step (replace $1n)))))))))
  ""
  "")

(defstep test ()
  (match ? "div_safe(%1,%2)" step (let ((divisor (args2(pvs-obj %2)))) (skip)))
  ""
  "")

;; (let ((error-locator '(!! 1 2))
;;       (e-expr (extra-get-expr error-locator)))
;;   (let((safe-ops (and (application? e-expr)
;; 		       (loop for arg in (arguments e-expr) 
;; 			     for i from 1 to (length (arguments e-expr))
;; 			     when (and (application? arg) (string= (string (id (operator arg))) "div_safe"))
;; 			     collect `(,(string (id (operator arg))) . ,(append error-locator (list i 1)))))))
;;     (when safe-ops
;;       (apply-for-each 
;;        safe-op 
;;        safe-ops 
;;        (let ((name (car safe-op))
;; 	     (locator  (cdr safe-op)))
;; 	 (then 
;; 	  (expand name)
;; 	  (let ((guard (extra-get-expr locator))
;; 		(match-str (show (format nil "^~a$" guard))))
;; 	    (match match-str step (replace $1n)))))))))


;; (let ((safe-ops '(("div_safe" . '(!! 1 2 1 1))))) 
;;   (apply-for-each 
;;    safe-op 
;;    safe-ops 
;;    (let ((name (car safe-op))
;; 	 (locator  (cdr safe-op)))
;;      (then 
;;       (expand name)
;;      (let ((guard (extra-get-expr locator))
;; 	   (match-str (show (format nil "^~a$" guard))))
;;        (match match-str step (replace $1n)))))))

    
      
;;       (apply-for-each op-name safe-op-names
;; 		      (then
;; 		       (expand op-name)
;; 		       (let ((locs (list (extra-get-expr (list '!! 1 2 1 1))))) (apply-for-each sub-expr locs (let ((match-str (format nil "^~a$" sub-expr))) (match match-str step (replace $1n))))))))))


;; (let ((expr "r_vz = 0")) (let ((match-str (format nil "^~a$" expr))) (match ? match-str step (replace $1n))))

;; (let ((fnums (list 3))
;;        (exprs (list "div_safe")))
;;   (apply-for-each expr exprs (then (expand expr)
;;   (apply-for-each fnum fnums (replace fnum)))))


;; (match ? "div_safe(%1,%2)" step (let ((divisor (args2(ee-pvs-obj $1)))) (if (ground-expr? divisor) (then (lemma "div_safe") (replace -1 :hide? t) (beta) (let ((guard (format nil "~a = 0" divisor))) (eval-expr guard)) (replace -1 :hide? t)) (skip))))
